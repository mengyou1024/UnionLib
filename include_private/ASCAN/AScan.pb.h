// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: AScan.proto
// Protobuf C++ Version: 5.27.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_AScan_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_AScan_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_AScan_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_AScan_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_AScan_2eproto;
namespace Union {
namespace AScan {
namespace Proto {
class AScanHead;
struct AScanHeadDefaultTypeInternal;
extern AScanHeadDefaultTypeInternal _AScanHead_default_instance_;
class AScanPayload;
struct AScanPayloadDefaultTypeInternal;
extern AScanPayloadDefaultTypeInternal _AScanPayload_default_instance_;
class AVG;
struct AVGDefaultTypeInternal;
extern AVGDefaultTypeInternal _AVG_default_instance_;
class ChannelParameter;
struct ChannelParameterDefaultTypeInternal;
extern ChannelParameterDefaultTypeInternal _ChannelParameter_default_instance_;
class DAC;
struct DACDefaultTypeInternal;
extern DACDefaultTypeInternal _DAC_default_instance_;
class DACCriteriaBias;
struct DACCriteriaBiasDefaultTypeInternal;
extern DACCriteriaBiasDefaultTypeInternal _DACCriteriaBias_default_instance_;
class Gate;
struct GateDefaultTypeInternal;
extern GateDefaultTypeInternal _Gate_default_instance_;
class InstrumentParameter;
struct InstrumentParameterDefaultTypeInternal;
extern InstrumentParameterDefaultTypeInternal _InstrumentParameter_default_instance_;
class Performance;
struct PerformanceDefaultTypeInternal;
extern PerformanceDefaultTypeInternal _Performance_default_instance_;
}  // namespace Proto
}  // namespace AScan
}  // namespace Union
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace Union {
namespace AScan {
namespace Proto {
enum Probe : int {
  NormalProbe = 0,
  ObliqueProbe = 1,
  TwinCrystalLongitudinalWaveNormalprobe = 2,
  PenetrationProbe = 3,
  TwinCrystaLongitudinalWaveObliqueProbe = 4,
  Probe_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Probe_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Probe_IsValid(int value);
extern const uint32_t Probe_internal_data_[];
constexpr Probe Probe_MIN = static_cast<Probe>(0);
constexpr Probe Probe_MAX = static_cast<Probe>(4);
constexpr int Probe_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
Probe_descriptor();
template <typename T>
const std::string& Probe_Name(T value) {
  static_assert(std::is_same<T, Probe>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Probe_Name().");
  return Probe_Name(static_cast<Probe>(value));
}
template <>
inline const std::string& Probe_Name(Probe value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Probe_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool Probe_Parse(absl::string_view name, Probe* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Probe>(
      Probe_descriptor(), name, value);
}
enum DACCriteria : int {
  None = 0,
  RL = 1,
  SL = 2,
  EL = 3,
  DACCriteria_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DACCriteria_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DACCriteria_IsValid(int value);
extern const uint32_t DACCriteria_internal_data_[];
constexpr DACCriteria DACCriteria_MIN = static_cast<DACCriteria>(0);
constexpr DACCriteria DACCriteria_MAX = static_cast<DACCriteria>(3);
constexpr int DACCriteria_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
DACCriteria_descriptor();
template <typename T>
const std::string& DACCriteria_Name(T value) {
  static_assert(std::is_same<T, DACCriteria>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DACCriteria_Name().");
  return DACCriteria_Name(static_cast<DACCriteria>(value));
}
template <>
inline const std::string& DACCriteria_Name(DACCriteria value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DACCriteria_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool DACCriteria_Parse(absl::string_view name, DACCriteria* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DACCriteria>(
      DACCriteria_descriptor(), name, value);
}
enum DistanceMode : int {
  Y = 0,
  X = 1,
  S = 2,
  DistanceMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DistanceMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DistanceMode_IsValid(int value);
extern const uint32_t DistanceMode_internal_data_[];
constexpr DistanceMode DistanceMode_MIN = static_cast<DistanceMode>(0);
constexpr DistanceMode DistanceMode_MAX = static_cast<DistanceMode>(2);
constexpr int DistanceMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
DistanceMode_descriptor();
template <typename T>
const std::string& DistanceMode_Name(T value) {
  static_assert(std::is_same<T, DistanceMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DistanceMode_Name().");
  return DistanceMode_Name(static_cast<DistanceMode>(value));
}
template <>
inline const std::string& DistanceMode_Name(DistanceMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DistanceMode_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool DistanceMode_Parse(absl::string_view name, DistanceMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DistanceMode>(
      DistanceMode_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Performance final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Union.AScan.Proto.Performance) */ {
 public:
  inline Performance() : Performance(nullptr) {}
  ~Performance() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Performance(
      ::google::protobuf::internal::ConstantInitialized);

  inline Performance(const Performance& from) : Performance(nullptr, from) {}
  inline Performance(Performance&& from) noexcept
      : Performance(nullptr, std::move(from)) {}
  inline Performance& operator=(const Performance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Performance& operator=(Performance&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Performance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Performance* internal_default_instance() {
    return reinterpret_cast<const Performance*>(
        &_Performance_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Performance& a, Performance& b) { a.Swap(&b); }
  inline void Swap(Performance* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Performance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Performance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Performance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Performance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Performance& from) { Performance::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Performance* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Union.AScan.Proto.Performance"; }

 protected:
  explicit Performance(::google::protobuf::Arena* arena);
  Performance(::google::protobuf::Arena* arena, const Performance& from);
  Performance(::google::protobuf::Arena* arena, Performance&& from) noexcept
      : Performance(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHorizontalLinearityFieldNumber = 1,
    kVerticalLinearityFieldNumber = 2,
    kResolutionFieldNumber = 3,
    kDynamicRangeFieldNumber = 4,
    kSurplusSensitivityFieldNumber = 5,
  };
  // float horizontalLinearity = 1;
  void clear_horizontallinearity() ;
  float horizontallinearity() const;
  void set_horizontallinearity(float value);

  private:
  float _internal_horizontallinearity() const;
  void _internal_set_horizontallinearity(float value);

  public:
  // float verticalLinearity = 2;
  void clear_verticallinearity() ;
  float verticallinearity() const;
  void set_verticallinearity(float value);

  private:
  float _internal_verticallinearity() const;
  void _internal_set_verticallinearity(float value);

  public:
  // float resolution = 3;
  void clear_resolution() ;
  float resolution() const;
  void set_resolution(float value);

  private:
  float _internal_resolution() const;
  void _internal_set_resolution(float value);

  public:
  // float dynamicRange = 4;
  void clear_dynamicrange() ;
  float dynamicrange() const;
  void set_dynamicrange(float value);

  private:
  float _internal_dynamicrange() const;
  void _internal_set_dynamicrange(float value);

  public:
  // float surplusSensitivity = 5;
  void clear_surplussensitivity() ;
  float surplussensitivity() const;
  void set_surplussensitivity(float value);

  private:
  float _internal_surplussensitivity() const;
  void _internal_set_surplussensitivity(float value);

  public:
  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.Performance)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Performance_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Performance& from_msg);
    float horizontallinearity_;
    float verticallinearity_;
    float resolution_;
    float dynamicrange_;
    float surplussensitivity_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// -------------------------------------------------------------------

class Gate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Union.AScan.Proto.Gate) */ {
 public:
  inline Gate() : Gate(nullptr) {}
  ~Gate() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Gate(
      ::google::protobuf::internal::ConstantInitialized);

  inline Gate(const Gate& from) : Gate(nullptr, from) {}
  inline Gate(Gate&& from) noexcept
      : Gate(nullptr, std::move(from)) {}
  inline Gate& operator=(const Gate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gate& operator=(Gate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gate* internal_default_instance() {
    return reinterpret_cast<const Gate*>(
        &_Gate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Gate& a, Gate& b) { a.Swap(&b); }
  inline void Swap(Gate* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Gate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Gate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Gate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Gate& from) { Gate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Gate* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Union.AScan.Proto.Gate"; }

 protected:
  explicit Gate(::google::protobuf::Arena* arena);
  Gate(::google::protobuf::Arena* arena, const Gate& from);
  Gate(::google::protobuf::Arena* arena, Gate&& from) noexcept
      : Gate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdxFieldNumber = 1,
    kPosFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // int32 idx = 1;
  void clear_idx() ;
  ::int32_t idx() const;
  void set_idx(::int32_t value);

  private:
  ::int32_t _internal_idx() const;
  void _internal_set_idx(::int32_t value);

  public:
  // float pos = 2;
  void clear_pos() ;
  float pos() const;
  void set_pos(float value);

  private:
  float _internal_pos() const;
  void _internal_set_pos(float value);

  public:
  // float width = 3;
  void clear_width() ;
  float width() const;
  void set_width(float value);

  private:
  float _internal_width() const;
  void _internal_set_width(float value);

  public:
  // float height = 4;
  void clear_height() ;
  float height() const;
  void set_height(float value);

  private:
  float _internal_height() const;
  void _internal_set_height(float value);

  public:
  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.Gate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Gate_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Gate& from_msg);
    ::int32_t idx_;
    float pos_;
    float width_;
    float height_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// -------------------------------------------------------------------

class DACCriteriaBias final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Union.AScan.Proto.DACCriteriaBias) */ {
 public:
  inline DACCriteriaBias() : DACCriteriaBias(nullptr) {}
  ~DACCriteriaBias() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DACCriteriaBias(
      ::google::protobuf::internal::ConstantInitialized);

  inline DACCriteriaBias(const DACCriteriaBias& from) : DACCriteriaBias(nullptr, from) {}
  inline DACCriteriaBias(DACCriteriaBias&& from) noexcept
      : DACCriteriaBias(nullptr, std::move(from)) {}
  inline DACCriteriaBias& operator=(const DACCriteriaBias& from) {
    CopyFrom(from);
    return *this;
  }
  inline DACCriteriaBias& operator=(DACCriteriaBias&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DACCriteriaBias& default_instance() {
    return *internal_default_instance();
  }
  static inline const DACCriteriaBias* internal_default_instance() {
    return reinterpret_cast<const DACCriteriaBias*>(
        &_DACCriteriaBias_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(DACCriteriaBias& a, DACCriteriaBias& b) { a.Swap(&b); }
  inline void Swap(DACCriteriaBias* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DACCriteriaBias* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DACCriteriaBias* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DACCriteriaBias>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DACCriteriaBias& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DACCriteriaBias& from) { DACCriteriaBias::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DACCriteriaBias* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Union.AScan.Proto.DACCriteriaBias"; }

 protected:
  explicit DACCriteriaBias(::google::protobuf::Arena* arena);
  DACCriteriaBias(::google::protobuf::Arena* arena, const DACCriteriaBias& from);
  DACCriteriaBias(::google::protobuf::Arena* arena, DACCriteriaBias&& from) noexcept
      : DACCriteriaBias(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRlBiasFieldNumber = 1,
    kSlBiasFieldNumber = 2,
    kElBiasFieldNumber = 3,
  };
  // sint32 rlBias = 1;
  void clear_rlbias() ;
  ::int32_t rlbias() const;
  void set_rlbias(::int32_t value);

  private:
  ::int32_t _internal_rlbias() const;
  void _internal_set_rlbias(::int32_t value);

  public:
  // sint32 slBias = 2;
  void clear_slbias() ;
  ::int32_t slbias() const;
  void set_slbias(::int32_t value);

  private:
  ::int32_t _internal_slbias() const;
  void _internal_set_slbias(::int32_t value);

  public:
  // sint32 elBias = 3;
  void clear_elbias() ;
  ::int32_t elbias() const;
  void set_elbias(::int32_t value);

  private:
  ::int32_t _internal_elbias() const;
  void _internal_set_elbias(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.DACCriteriaBias)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DACCriteriaBias_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DACCriteriaBias& from_msg);
    ::int32_t rlbias_;
    ::int32_t slbias_;
    ::int32_t elbias_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// -------------------------------------------------------------------

class AVG final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Union.AScan.Proto.AVG) */ {
 public:
  inline AVG() : AVG(nullptr) {}
  ~AVG() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AVG(
      ::google::protobuf::internal::ConstantInitialized);

  inline AVG(const AVG& from) : AVG(nullptr, from) {}
  inline AVG(AVG&& from) noexcept
      : AVG(nullptr, std::move(from)) {}
  inline AVG& operator=(const AVG& from) {
    CopyFrom(from);
    return *this;
  }
  inline AVG& operator=(AVG&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AVG& default_instance() {
    return *internal_default_instance();
  }
  static inline const AVG* internal_default_instance() {
    return reinterpret_cast<const AVG*>(
        &_AVG_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(AVG& a, AVG& b) { a.Swap(&b); }
  inline void Swap(AVG* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AVG* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AVG* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AVG>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AVG& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AVG& from) { AVG::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AVG* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Union.AScan.Proto.AVG"; }

 protected:
  explicit AVG(::google::protobuf::Arena* arena);
  AVG(::google::protobuf::Arena* arena, const AVG& from);
  AVG(::google::protobuf::Arena* arena, AVG&& from) noexcept
      : AVG(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIndexFieldNumber = 4,
    kValueFieldNumber = 5,
    kBaseGainFieldNumber = 1,
    kCompensatingGainFieldNumber = 2,
    kScanGainFieldNumber = 3,
    kIsSubLineFieldNumber = 6,
    kSamplingXAxisBiasFieldNumber = 7,
    kSamplingXAxisLenFieldNumber = 8,
    kDiameterFieldNumber = 9,
    kReflectorDiameterFieldNumber = 10,
    kReflectorMaxDepthFieldNumber = 11,
    kEquivalentFieldNumber = 12,
  };
  // repeated float index = 4;
  int index_size() const;
  private:
  int _internal_index_size() const;

  public:
  void clear_index() ;
  float index(int index) const;
  void set_index(int index, float value);
  void add_index(float value);
  const ::google::protobuf::RepeatedField<float>& index() const;
  ::google::protobuf::RepeatedField<float>* mutable_index();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_index() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_index();

  public:
  // repeated float value = 5;
  int value_size() const;
  private:
  int _internal_value_size() const;

  public:
  void clear_value() ;
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::google::protobuf::RepeatedField<float>& value() const;
  ::google::protobuf::RepeatedField<float>* mutable_value();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_value() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_value();

  public:
  // float baseGain = 1;
  void clear_basegain() ;
  float basegain() const;
  void set_basegain(float value);

  private:
  float _internal_basegain() const;
  void _internal_set_basegain(float value);

  public:
  // float compensatingGain = 2;
  void clear_compensatinggain() ;
  float compensatinggain() const;
  void set_compensatinggain(float value);

  private:
  float _internal_compensatinggain() const;
  void _internal_set_compensatinggain(float value);

  public:
  // float scanGain = 3;
  void clear_scangain() ;
  float scangain() const;
  void set_scangain(float value);

  private:
  float _internal_scangain() const;
  void _internal_set_scangain(float value);

  public:
  // bool isSubLine = 6;
  void clear_issubline() ;
  bool issubline() const;
  void set_issubline(bool value);

  private:
  bool _internal_issubline() const;
  void _internal_set_issubline(bool value);

  public:
  // float samplingXAxisBias = 7;
  void clear_samplingxaxisbias() ;
  float samplingxaxisbias() const;
  void set_samplingxaxisbias(float value);

  private:
  float _internal_samplingxaxisbias() const;
  void _internal_set_samplingxaxisbias(float value);

  public:
  // float samplingXAxisLen = 8;
  void clear_samplingxaxislen() ;
  float samplingxaxislen() const;
  void set_samplingxaxislen(float value);

  private:
  float _internal_samplingxaxislen() const;
  void _internal_set_samplingxaxislen(float value);

  public:
  // float diameter = 9;
  void clear_diameter() ;
  float diameter() const;
  void set_diameter(float value);

  private:
  float _internal_diameter() const;
  void _internal_set_diameter(float value);

  public:
  // float reflectorDiameter = 10;
  void clear_reflectordiameter() ;
  float reflectordiameter() const;
  void set_reflectordiameter(float value);

  private:
  float _internal_reflectordiameter() const;
  void _internal_set_reflectordiameter(float value);

  public:
  // float reflectorMaxDepth = 11;
  void clear_reflectormaxdepth() ;
  float reflectormaxdepth() const;
  void set_reflectormaxdepth(float value);

  private:
  float _internal_reflectormaxdepth() const;
  void _internal_set_reflectormaxdepth(float value);

  public:
  // float equivalent = 12;
  void clear_equivalent() ;
  float equivalent() const;
  void set_equivalent(float value);

  private:
  float _internal_equivalent() const;
  void _internal_set_equivalent(float value);

  public:
  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.AVG)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AVG_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AVG& from_msg);
    ::google::protobuf::RepeatedField<float> index_;
    ::google::protobuf::RepeatedField<float> value_;
    float basegain_;
    float compensatinggain_;
    float scangain_;
    bool issubline_;
    float samplingxaxisbias_;
    float samplingxaxislen_;
    float diameter_;
    float reflectordiameter_;
    float reflectormaxdepth_;
    float equivalent_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// -------------------------------------------------------------------

class AScanHead final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Union.AScan.Proto.AScanHead) */ {
 public:
  inline AScanHead() : AScanHead(nullptr) {}
  ~AScanHead() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AScanHead(
      ::google::protobuf::internal::ConstantInitialized);

  inline AScanHead(const AScanHead& from) : AScanHead(nullptr, from) {}
  inline AScanHead(AScanHead&& from) noexcept
      : AScanHead(nullptr, std::move(from)) {}
  inline AScanHead& operator=(const AScanHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline AScanHead& operator=(AScanHead&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AScanHead& default_instance() {
    return *internal_default_instance();
  }
  static inline const AScanHead* internal_default_instance() {
    return reinterpret_cast<const AScanHead*>(
        &_AScanHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(AScanHead& a, AScanHead& b) { a.Swap(&b); }
  inline void Swap(AScanHead* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AScanHead* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AScanHead* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AScanHead>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AScanHead& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AScanHead& from) { AScanHead::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AScanHead* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Union.AScan.Proto.AScanHead"; }

 protected:
  explicit AScanHead(::google::protobuf::Arena* arena);
  AScanHead(::google::protobuf::Arena* arena, const AScanHead& from);
  AScanHead(::google::protobuf::Arena* arena, AScanHead&& from) noexcept
      : AScanHead(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInstrumentNameFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // string instrumentName = 1;
  void clear_instrumentname() ;
  const std::string& instrumentname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_instrumentname(Arg_&& arg, Args_... args);
  std::string* mutable_instrumentname();
  PROTOBUF_NODISCARD std::string* release_instrumentname();
  void set_allocated_instrumentname(std::string* value);

  private:
  const std::string& _internal_instrumentname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrumentname(
      const std::string& value);
  std::string* _internal_mutable_instrumentname();

  public:
  // string time = 2;
  void clear_time() ;
  const std::string& time() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_time(Arg_&& arg, Args_... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* value);

  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(
      const std::string& value);
  std::string* _internal_mutable_time();

  public:
  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.AScanHead)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      54, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AScanHead_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AScanHead& from_msg);
    ::google::protobuf::internal::ArenaStringPtr instrumentname_;
    ::google::protobuf::internal::ArenaStringPtr time_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// -------------------------------------------------------------------

class InstrumentParameter final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Union.AScan.Proto.InstrumentParameter) */ {
 public:
  inline InstrumentParameter() : InstrumentParameter(nullptr) {}
  ~InstrumentParameter() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstrumentParameter(
      ::google::protobuf::internal::ConstantInitialized);

  inline InstrumentParameter(const InstrumentParameter& from) : InstrumentParameter(nullptr, from) {}
  inline InstrumentParameter(InstrumentParameter&& from) noexcept
      : InstrumentParameter(nullptr, std::move(from)) {}
  inline InstrumentParameter& operator=(const InstrumentParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstrumentParameter& operator=(InstrumentParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstrumentParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstrumentParameter* internal_default_instance() {
    return reinterpret_cast<const InstrumentParameter*>(
        &_InstrumentParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(InstrumentParameter& a, InstrumentParameter& b) { a.Swap(&b); }
  inline void Swap(InstrumentParameter* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstrumentParameter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstrumentParameter* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<InstrumentParameter>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstrumentParameter& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InstrumentParameter& from) { InstrumentParameter::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InstrumentParameter* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Union.AScan.Proto.InstrumentParameter"; }

 protected:
  explicit InstrumentParameter(::google::protobuf::Arena* arena);
  InstrumentParameter(::google::protobuf::Arena* arena, const InstrumentParameter& from);
  InstrumentParameter(::google::protobuf::Arena* arena, InstrumentParameter&& from) noexcept
      : InstrumentParameter(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPerformanceFieldNumber = 12,
    kProbeFieldNumber = 3,
    kProbeFrequenceFieldNumber = 4,
    kProbeChipShapeLFieldNumber = 5,
    kProbeChipShapeHFieldNumber = 6,
    kAngleFieldNumber = 7,
    kSoundVelocityFieldNumber = 8,
    kProbeFrontDistanceFieldNumber = 9,
    kZeroPointFieldNumber = 10,
    kChannelFieldNumber = 11,
  };
  // optional .Union.AScan.Proto.Performance performance = 12;
  bool has_performance() const;
  void clear_performance() ;
  const ::Union::AScan::Proto::Performance& performance() const;
  PROTOBUF_NODISCARD ::Union::AScan::Proto::Performance* release_performance();
  ::Union::AScan::Proto::Performance* mutable_performance();
  void set_allocated_performance(::Union::AScan::Proto::Performance* value);
  void unsafe_arena_set_allocated_performance(::Union::AScan::Proto::Performance* value);
  ::Union::AScan::Proto::Performance* unsafe_arena_release_performance();

  private:
  const ::Union::AScan::Proto::Performance& _internal_performance() const;
  ::Union::AScan::Proto::Performance* _internal_mutable_performance();

  public:
  // .Union.AScan.Proto.Probe probe = 3;
  void clear_probe() ;
  ::Union::AScan::Proto::Probe probe() const;
  void set_probe(::Union::AScan::Proto::Probe value);

  private:
  ::Union::AScan::Proto::Probe _internal_probe() const;
  void _internal_set_probe(::Union::AScan::Proto::Probe value);

  public:
  // float probeFrequence = 4;
  void clear_probefrequence() ;
  float probefrequence() const;
  void set_probefrequence(float value);

  private:
  float _internal_probefrequence() const;
  void _internal_set_probefrequence(float value);

  public:
  // float probeChipShapeL = 5;
  void clear_probechipshapel() ;
  float probechipshapel() const;
  void set_probechipshapel(float value);

  private:
  float _internal_probechipshapel() const;
  void _internal_set_probechipshapel(float value);

  public:
  // float probeChipShapeH = 6;
  void clear_probechipshapeh() ;
  float probechipshapeh() const;
  void set_probechipshapeh(float value);

  private:
  float _internal_probechipshapeh() const;
  void _internal_set_probechipshapeh(float value);

  public:
  // float angle = 7;
  void clear_angle() ;
  float angle() const;
  void set_angle(float value);

  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);

  public:
  // float soundVelocity = 8;
  void clear_soundvelocity() ;
  float soundvelocity() const;
  void set_soundvelocity(float value);

  private:
  float _internal_soundvelocity() const;
  void _internal_set_soundvelocity(float value);

  public:
  // float probeFrontDistance = 9;
  void clear_probefrontdistance() ;
  float probefrontdistance() const;
  void set_probefrontdistance(float value);

  private:
  float _internal_probefrontdistance() const;
  void _internal_set_probefrontdistance(float value);

  public:
  // float zeroPoint = 10;
  void clear_zeropoint() ;
  float zeropoint() const;
  void set_zeropoint(float value);

  private:
  float _internal_zeropoint() const;
  void _internal_set_zeropoint(float value);

  public:
  // int32 channel = 11;
  void clear_channel() ;
  ::int32_t channel() const;
  void set_channel(::int32_t value);

  private:
  ::int32_t _internal_channel() const;
  void _internal_set_channel(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.InstrumentParameter)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_InstrumentParameter_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InstrumentParameter& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Union::AScan::Proto::Performance* performance_;
    int probe_;
    float probefrequence_;
    float probechipshapel_;
    float probechipshapeh_;
    float angle_;
    float soundvelocity_;
    float probefrontdistance_;
    float zeropoint_;
    ::int32_t channel_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// -------------------------------------------------------------------

class DAC final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Union.AScan.Proto.DAC) */ {
 public:
  inline DAC() : DAC(nullptr) {}
  ~DAC() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DAC(
      ::google::protobuf::internal::ConstantInitialized);

  inline DAC(const DAC& from) : DAC(nullptr, from) {}
  inline DAC(DAC&& from) noexcept
      : DAC(nullptr, std::move(from)) {}
  inline DAC& operator=(const DAC& from) {
    CopyFrom(from);
    return *this;
  }
  inline DAC& operator=(DAC&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DAC& default_instance() {
    return *internal_default_instance();
  }
  static inline const DAC* internal_default_instance() {
    return reinterpret_cast<const DAC*>(
        &_DAC_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(DAC& a, DAC& b) { a.Swap(&b); }
  inline void Swap(DAC* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DAC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DAC* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DAC>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DAC& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DAC& from) { DAC::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DAC* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Union.AScan.Proto.DAC"; }

 protected:
  explicit DAC(::google::protobuf::Arena* arena);
  DAC(::google::protobuf::Arena* arena, const DAC& from);
  DAC(::google::protobuf::Arena* arena, DAC&& from) noexcept
      : DAC(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIndexFieldNumber = 3,
    kValueFieldNumber = 4,
    kCriteriaBiasFieldNumber = 7,
    kBaseGainFieldNumber = 1,
    kCompensatingGainFieldNumber = 2,
    kEquivalentFieldNumber = 5,
    kCriteriaFieldNumber = 6,
    kIsSubLineFieldNumber = 8,
    kSamplingXAxisBiasFieldNumber = 9,
    kSamplingXAxisLenFieldNumber = 10,
  };
  // repeated float index = 3;
  int index_size() const;
  private:
  int _internal_index_size() const;

  public:
  void clear_index() ;
  float index(int index) const;
  void set_index(int index, float value);
  void add_index(float value);
  const ::google::protobuf::RepeatedField<float>& index() const;
  ::google::protobuf::RepeatedField<float>* mutable_index();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_index() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_index();

  public:
  // repeated float value = 4;
  int value_size() const;
  private:
  int _internal_value_size() const;

  public:
  void clear_value() ;
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::google::protobuf::RepeatedField<float>& value() const;
  ::google::protobuf::RepeatedField<float>* mutable_value();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_value() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_value();

  public:
  // optional .Union.AScan.Proto.DACCriteriaBias criteriaBias = 7;
  bool has_criteriabias() const;
  void clear_criteriabias() ;
  const ::Union::AScan::Proto::DACCriteriaBias& criteriabias() const;
  PROTOBUF_NODISCARD ::Union::AScan::Proto::DACCriteriaBias* release_criteriabias();
  ::Union::AScan::Proto::DACCriteriaBias* mutable_criteriabias();
  void set_allocated_criteriabias(::Union::AScan::Proto::DACCriteriaBias* value);
  void unsafe_arena_set_allocated_criteriabias(::Union::AScan::Proto::DACCriteriaBias* value);
  ::Union::AScan::Proto::DACCriteriaBias* unsafe_arena_release_criteriabias();

  private:
  const ::Union::AScan::Proto::DACCriteriaBias& _internal_criteriabias() const;
  ::Union::AScan::Proto::DACCriteriaBias* _internal_mutable_criteriabias();

  public:
  // float baseGain = 1;
  void clear_basegain() ;
  float basegain() const;
  void set_basegain(float value);

  private:
  float _internal_basegain() const;
  void _internal_set_basegain(float value);

  public:
  // float compensatingGain = 2;
  void clear_compensatinggain() ;
  float compensatinggain() const;
  void set_compensatinggain(float value);

  private:
  float _internal_compensatinggain() const;
  void _internal_set_compensatinggain(float value);

  public:
  // float equivalent = 5;
  void clear_equivalent() ;
  float equivalent() const;
  void set_equivalent(float value);

  private:
  float _internal_equivalent() const;
  void _internal_set_equivalent(float value);

  public:
  // .Union.AScan.Proto.DACCriteria criteria = 6;
  void clear_criteria() ;
  ::Union::AScan::Proto::DACCriteria criteria() const;
  void set_criteria(::Union::AScan::Proto::DACCriteria value);

  private:
  ::Union::AScan::Proto::DACCriteria _internal_criteria() const;
  void _internal_set_criteria(::Union::AScan::Proto::DACCriteria value);

  public:
  // bool isSubLine = 8;
  void clear_issubline() ;
  bool issubline() const;
  void set_issubline(bool value);

  private:
  bool _internal_issubline() const;
  void _internal_set_issubline(bool value);

  public:
  // float samplingXAxisBias = 9;
  void clear_samplingxaxisbias() ;
  float samplingxaxisbias() const;
  void set_samplingxaxisbias(float value);

  private:
  float _internal_samplingxaxisbias() const;
  void _internal_set_samplingxaxisbias(float value);

  public:
  // float samplingXAxisLen = 10;
  void clear_samplingxaxislen() ;
  float samplingxaxislen() const;
  void set_samplingxaxislen(float value);

  private:
  float _internal_samplingxaxislen() const;
  void _internal_set_samplingxaxislen(float value);

  public:
  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.DAC)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DAC_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DAC& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> index_;
    ::google::protobuf::RepeatedField<float> value_;
    ::Union::AScan::Proto::DACCriteriaBias* criteriabias_;
    float basegain_;
    float compensatinggain_;
    float equivalent_;
    int criteria_;
    bool issubline_;
    float samplingxaxisbias_;
    float samplingxaxislen_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// -------------------------------------------------------------------

class ChannelParameter final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Union.AScan.Proto.ChannelParameter) */ {
 public:
  inline ChannelParameter() : ChannelParameter(nullptr) {}
  ~ChannelParameter() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelParameter(
      ::google::protobuf::internal::ConstantInitialized);

  inline ChannelParameter(const ChannelParameter& from) : ChannelParameter(nullptr, from) {}
  inline ChannelParameter(ChannelParameter&& from) noexcept
      : ChannelParameter(nullptr, std::move(from)) {}
  inline ChannelParameter& operator=(const ChannelParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelParameter& operator=(ChannelParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelParameter* internal_default_instance() {
    return reinterpret_cast<const ChannelParameter*>(
        &_ChannelParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ChannelParameter& a, ChannelParameter& b) { a.Swap(&b); }
  inline void Swap(ChannelParameter* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelParameter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelParameter* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ChannelParameter>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelParameter& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChannelParameter& from) { ChannelParameter::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelParameter* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Union.AScan.Proto.ChannelParameter"; }

 protected:
  explicit ChannelParameter(::google::protobuf::Arena* arena);
  ChannelParameter(::google::protobuf::Arena* arena, const ChannelParameter& from);
  ChannelParameter(::google::protobuf::Arena* arena, ChannelParameter&& from) noexcept
      : ChannelParameter(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGateFieldNumber = 1,
    kAscanFieldNumber = 2,
    kDacFieldNumber = 10,
    kAvgFieldNumber = 11,
    kPerformanceFieldNumber = 12,
    kAxisBiasFieldNumber = 3,
    kAxisLenFieldNumber = 4,
    kBaseGainFieldNumber = 5,
    kScanGainFieldNumber = 6,
    kCompensatingGainFieldNumber = 7,
    kSuppressionFieldNumber = 8,
    kDistanceModeFieldNumber = 9,
  };
  // repeated .Union.AScan.Proto.Gate gate = 1;
  int gate_size() const;
  private:
  int _internal_gate_size() const;

  public:
  void clear_gate() ;
  ::Union::AScan::Proto::Gate* mutable_gate(int index);
  ::google::protobuf::RepeatedPtrField<::Union::AScan::Proto::Gate>* mutable_gate();

  private:
  const ::google::protobuf::RepeatedPtrField<::Union::AScan::Proto::Gate>& _internal_gate() const;
  ::google::protobuf::RepeatedPtrField<::Union::AScan::Proto::Gate>* _internal_mutable_gate();
  public:
  const ::Union::AScan::Proto::Gate& gate(int index) const;
  ::Union::AScan::Proto::Gate* add_gate();
  const ::google::protobuf::RepeatedPtrField<::Union::AScan::Proto::Gate>& gate() const;
  // bytes ascan = 2;
  void clear_ascan() ;
  const std::string& ascan() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ascan(Arg_&& arg, Args_... args);
  std::string* mutable_ascan();
  PROTOBUF_NODISCARD std::string* release_ascan();
  void set_allocated_ascan(std::string* value);

  private:
  const std::string& _internal_ascan() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ascan(
      const std::string& value);
  std::string* _internal_mutable_ascan();

  public:
  // optional .Union.AScan.Proto.DAC dac = 10;
  bool has_dac() const;
  void clear_dac() ;
  const ::Union::AScan::Proto::DAC& dac() const;
  PROTOBUF_NODISCARD ::Union::AScan::Proto::DAC* release_dac();
  ::Union::AScan::Proto::DAC* mutable_dac();
  void set_allocated_dac(::Union::AScan::Proto::DAC* value);
  void unsafe_arena_set_allocated_dac(::Union::AScan::Proto::DAC* value);
  ::Union::AScan::Proto::DAC* unsafe_arena_release_dac();

  private:
  const ::Union::AScan::Proto::DAC& _internal_dac() const;
  ::Union::AScan::Proto::DAC* _internal_mutable_dac();

  public:
  // optional .Union.AScan.Proto.AVG avg = 11;
  bool has_avg() const;
  void clear_avg() ;
  const ::Union::AScan::Proto::AVG& avg() const;
  PROTOBUF_NODISCARD ::Union::AScan::Proto::AVG* release_avg();
  ::Union::AScan::Proto::AVG* mutable_avg();
  void set_allocated_avg(::Union::AScan::Proto::AVG* value);
  void unsafe_arena_set_allocated_avg(::Union::AScan::Proto::AVG* value);
  ::Union::AScan::Proto::AVG* unsafe_arena_release_avg();

  private:
  const ::Union::AScan::Proto::AVG& _internal_avg() const;
  ::Union::AScan::Proto::AVG* _internal_mutable_avg();

  public:
  // optional .Union.AScan.Proto.Performance performance = 12;
  bool has_performance() const;
  void clear_performance() ;
  const ::Union::AScan::Proto::Performance& performance() const;
  PROTOBUF_NODISCARD ::Union::AScan::Proto::Performance* release_performance();
  ::Union::AScan::Proto::Performance* mutable_performance();
  void set_allocated_performance(::Union::AScan::Proto::Performance* value);
  void unsafe_arena_set_allocated_performance(::Union::AScan::Proto::Performance* value);
  ::Union::AScan::Proto::Performance* unsafe_arena_release_performance();

  private:
  const ::Union::AScan::Proto::Performance& _internal_performance() const;
  ::Union::AScan::Proto::Performance* _internal_mutable_performance();

  public:
  // float axisBias = 3;
  void clear_axisbias() ;
  float axisbias() const;
  void set_axisbias(float value);

  private:
  float _internal_axisbias() const;
  void _internal_set_axisbias(float value);

  public:
  // float axisLen = 4;
  void clear_axislen() ;
  float axislen() const;
  void set_axislen(float value);

  private:
  float _internal_axislen() const;
  void _internal_set_axislen(float value);

  public:
  // float baseGain = 5;
  void clear_basegain() ;
  float basegain() const;
  void set_basegain(float value);

  private:
  float _internal_basegain() const;
  void _internal_set_basegain(float value);

  public:
  // float scanGain = 6;
  void clear_scangain() ;
  float scangain() const;
  void set_scangain(float value);

  private:
  float _internal_scangain() const;
  void _internal_set_scangain(float value);

  public:
  // float compensatingGain = 7;
  void clear_compensatinggain() ;
  float compensatinggain() const;
  void set_compensatinggain(float value);

  private:
  float _internal_compensatinggain() const;
  void _internal_set_compensatinggain(float value);

  public:
  // int32 suppression = 8;
  void clear_suppression() ;
  ::int32_t suppression() const;
  void set_suppression(::int32_t value);

  private:
  ::int32_t _internal_suppression() const;
  void _internal_set_suppression(::int32_t value);

  public:
  // .Union.AScan.Proto.DistanceMode distanceMode = 9;
  void clear_distancemode() ;
  ::Union::AScan::Proto::DistanceMode distancemode() const;
  void set_distancemode(::Union::AScan::Proto::DistanceMode value);

  private:
  ::Union::AScan::Proto::DistanceMode _internal_distancemode() const;
  void _internal_set_distancemode(::Union::AScan::Proto::DistanceMode value);

  public:
  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.ChannelParameter)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 4,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ChannelParameter_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ChannelParameter& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::Union::AScan::Proto::Gate > gate_;
    ::google::protobuf::internal::ArenaStringPtr ascan_;
    ::Union::AScan::Proto::DAC* dac_;
    ::Union::AScan::Proto::AVG* avg_;
    ::Union::AScan::Proto::Performance* performance_;
    float axisbias_;
    float axislen_;
    float basegain_;
    float scangain_;
    float compensatinggain_;
    ::int32_t suppression_;
    int distancemode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// -------------------------------------------------------------------

class AScanPayload final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Union.AScan.Proto.AScanPayload) */ {
 public:
  inline AScanPayload() : AScanPayload(nullptr) {}
  ~AScanPayload() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AScanPayload(
      ::google::protobuf::internal::ConstantInitialized);

  inline AScanPayload(const AScanPayload& from) : AScanPayload(nullptr, from) {}
  inline AScanPayload(AScanPayload&& from) noexcept
      : AScanPayload(nullptr, std::move(from)) {}
  inline AScanPayload& operator=(const AScanPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline AScanPayload& operator=(AScanPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AScanPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const AScanPayload* internal_default_instance() {
    return reinterpret_cast<const AScanPayload*>(
        &_AScanPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(AScanPayload& a, AScanPayload& b) { a.Swap(&b); }
  inline void Swap(AScanPayload* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AScanPayload* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AScanPayload* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AScanPayload>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AScanPayload& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AScanPayload& from) { AScanPayload::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AScanPayload* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Union.AScan.Proto.AScanPayload"; }

 protected:
  explicit AScanPayload(::google::protobuf::Arena* arena);
  AScanPayload(::google::protobuf::Arena* arena, const AScanPayload& from);
  AScanPayload(::google::protobuf::Arena* arena, AScanPayload&& from) noexcept
      : AScanPayload(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCameraDataFieldNumber = 3,
    kInstrumentParameterFieldNumber = 1,
    kChannelParameterFieldNumber = 2,
  };
  // optional bytes cameraData = 3;
  bool has_cameradata() const;
  void clear_cameradata() ;
  const std::string& cameradata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cameradata(Arg_&& arg, Args_... args);
  std::string* mutable_cameradata();
  PROTOBUF_NODISCARD std::string* release_cameradata();
  void set_allocated_cameradata(std::string* value);

  private:
  const std::string& _internal_cameradata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cameradata(
      const std::string& value);
  std::string* _internal_mutable_cameradata();

  public:
  // .Union.AScan.Proto.InstrumentParameter instrumentParameter = 1;
  bool has_instrumentparameter() const;
  void clear_instrumentparameter() ;
  const ::Union::AScan::Proto::InstrumentParameter& instrumentparameter() const;
  PROTOBUF_NODISCARD ::Union::AScan::Proto::InstrumentParameter* release_instrumentparameter();
  ::Union::AScan::Proto::InstrumentParameter* mutable_instrumentparameter();
  void set_allocated_instrumentparameter(::Union::AScan::Proto::InstrumentParameter* value);
  void unsafe_arena_set_allocated_instrumentparameter(::Union::AScan::Proto::InstrumentParameter* value);
  ::Union::AScan::Proto::InstrumentParameter* unsafe_arena_release_instrumentparameter();

  private:
  const ::Union::AScan::Proto::InstrumentParameter& _internal_instrumentparameter() const;
  ::Union::AScan::Proto::InstrumentParameter* _internal_mutable_instrumentparameter();

  public:
  // .Union.AScan.Proto.ChannelParameter channelParameter = 2;
  bool has_channelparameter() const;
  void clear_channelparameter() ;
  const ::Union::AScan::Proto::ChannelParameter& channelparameter() const;
  PROTOBUF_NODISCARD ::Union::AScan::Proto::ChannelParameter* release_channelparameter();
  ::Union::AScan::Proto::ChannelParameter* mutable_channelparameter();
  void set_allocated_channelparameter(::Union::AScan::Proto::ChannelParameter* value);
  void unsafe_arena_set_allocated_channelparameter(::Union::AScan::Proto::ChannelParameter* value);
  ::Union::AScan::Proto::ChannelParameter* unsafe_arena_release_channelparameter();

  private:
  const ::Union::AScan::Proto::ChannelParameter& _internal_channelparameter() const;
  ::Union::AScan::Proto::ChannelParameter* _internal_mutable_channelparameter();

  public:
  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.AScanPayload)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AScanPayload_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AScanPayload& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr cameradata_;
    ::Union::AScan::Proto::InstrumentParameter* instrumentparameter_;
    ::Union::AScan::Proto::ChannelParameter* channelparameter_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Performance

// float horizontalLinearity = 1;
inline void Performance::clear_horizontallinearity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.horizontallinearity_ = 0;
}
inline float Performance::horizontallinearity() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Performance.horizontalLinearity)
  return _internal_horizontallinearity();
}
inline void Performance::set_horizontallinearity(float value) {
  _internal_set_horizontallinearity(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Performance.horizontalLinearity)
}
inline float Performance::_internal_horizontallinearity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.horizontallinearity_;
}
inline void Performance::_internal_set_horizontallinearity(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.horizontallinearity_ = value;
}

// float verticalLinearity = 2;
inline void Performance::clear_verticallinearity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verticallinearity_ = 0;
}
inline float Performance::verticallinearity() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Performance.verticalLinearity)
  return _internal_verticallinearity();
}
inline void Performance::set_verticallinearity(float value) {
  _internal_set_verticallinearity(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Performance.verticalLinearity)
}
inline float Performance::_internal_verticallinearity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.verticallinearity_;
}
inline void Performance::_internal_set_verticallinearity(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verticallinearity_ = value;
}

// float resolution = 3;
inline void Performance::clear_resolution() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_ = 0;
}
inline float Performance::resolution() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Performance.resolution)
  return _internal_resolution();
}
inline void Performance::set_resolution(float value) {
  _internal_set_resolution(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Performance.resolution)
}
inline float Performance::_internal_resolution() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resolution_;
}
inline void Performance::_internal_set_resolution(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_ = value;
}

// float dynamicRange = 4;
inline void Performance::clear_dynamicrange() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dynamicrange_ = 0;
}
inline float Performance::dynamicrange() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Performance.dynamicRange)
  return _internal_dynamicrange();
}
inline void Performance::set_dynamicrange(float value) {
  _internal_set_dynamicrange(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Performance.dynamicRange)
}
inline float Performance::_internal_dynamicrange() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dynamicrange_;
}
inline void Performance::_internal_set_dynamicrange(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dynamicrange_ = value;
}

// float surplusSensitivity = 5;
inline void Performance::clear_surplussensitivity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.surplussensitivity_ = 0;
}
inline float Performance::surplussensitivity() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Performance.surplusSensitivity)
  return _internal_surplussensitivity();
}
inline void Performance::set_surplussensitivity(float value) {
  _internal_set_surplussensitivity(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Performance.surplusSensitivity)
}
inline float Performance::_internal_surplussensitivity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.surplussensitivity_;
}
inline void Performance::_internal_set_surplussensitivity(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.surplussensitivity_ = value;
}

// -------------------------------------------------------------------

// Gate

// int32 idx = 1;
inline void Gate::clear_idx() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.idx_ = 0;
}
inline ::int32_t Gate::idx() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Gate.idx)
  return _internal_idx();
}
inline void Gate::set_idx(::int32_t value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Gate.idx)
}
inline ::int32_t Gate::_internal_idx() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.idx_;
}
inline void Gate::_internal_set_idx(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.idx_ = value;
}

// float pos = 2;
inline void Gate::clear_pos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pos_ = 0;
}
inline float Gate::pos() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Gate.pos)
  return _internal_pos();
}
inline void Gate::set_pos(float value) {
  _internal_set_pos(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Gate.pos)
}
inline float Gate::_internal_pos() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pos_;
}
inline void Gate::_internal_set_pos(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pos_ = value;
}

// float width = 3;
inline void Gate::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0;
}
inline float Gate::width() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Gate.width)
  return _internal_width();
}
inline void Gate::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Gate.width)
}
inline float Gate::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void Gate::_internal_set_width(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// float height = 4;
inline void Gate::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0;
}
inline float Gate::height() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Gate.height)
  return _internal_height();
}
inline void Gate::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Gate.height)
}
inline float Gate::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void Gate::_internal_set_height(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// -------------------------------------------------------------------

// DACCriteriaBias

// sint32 rlBias = 1;
inline void DACCriteriaBias::clear_rlbias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rlbias_ = 0;
}
inline ::int32_t DACCriteriaBias::rlbias() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DACCriteriaBias.rlBias)
  return _internal_rlbias();
}
inline void DACCriteriaBias::set_rlbias(::int32_t value) {
  _internal_set_rlbias(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DACCriteriaBias.rlBias)
}
inline ::int32_t DACCriteriaBias::_internal_rlbias() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rlbias_;
}
inline void DACCriteriaBias::_internal_set_rlbias(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rlbias_ = value;
}

// sint32 slBias = 2;
inline void DACCriteriaBias::clear_slbias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slbias_ = 0;
}
inline ::int32_t DACCriteriaBias::slbias() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DACCriteriaBias.slBias)
  return _internal_slbias();
}
inline void DACCriteriaBias::set_slbias(::int32_t value) {
  _internal_set_slbias(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DACCriteriaBias.slBias)
}
inline ::int32_t DACCriteriaBias::_internal_slbias() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slbias_;
}
inline void DACCriteriaBias::_internal_set_slbias(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slbias_ = value;
}

// sint32 elBias = 3;
inline void DACCriteriaBias::clear_elbias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.elbias_ = 0;
}
inline ::int32_t DACCriteriaBias::elbias() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DACCriteriaBias.elBias)
  return _internal_elbias();
}
inline void DACCriteriaBias::set_elbias(::int32_t value) {
  _internal_set_elbias(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DACCriteriaBias.elBias)
}
inline ::int32_t DACCriteriaBias::_internal_elbias() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.elbias_;
}
inline void DACCriteriaBias::_internal_set_elbias(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.elbias_ = value;
}

// -------------------------------------------------------------------

// DAC

// float baseGain = 1;
inline void DAC::clear_basegain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.basegain_ = 0;
}
inline float DAC::basegain() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.baseGain)
  return _internal_basegain();
}
inline void DAC::set_basegain(float value) {
  _internal_set_basegain(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.baseGain)
}
inline float DAC::_internal_basegain() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.basegain_;
}
inline void DAC::_internal_set_basegain(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.basegain_ = value;
}

// float compensatingGain = 2;
inline void DAC::clear_compensatinggain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compensatinggain_ = 0;
}
inline float DAC::compensatinggain() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.compensatingGain)
  return _internal_compensatinggain();
}
inline void DAC::set_compensatinggain(float value) {
  _internal_set_compensatinggain(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.compensatingGain)
}
inline float DAC::_internal_compensatinggain() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.compensatinggain_;
}
inline void DAC::_internal_set_compensatinggain(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compensatinggain_ = value;
}

// repeated float index = 3;
inline int DAC::_internal_index_size() const {
  return _internal_index().size();
}
inline int DAC::index_size() const {
  return _internal_index_size();
}
inline void DAC::clear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_.Clear();
}
inline float DAC::index(int index) const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.index)
  return _internal_index().Get(index);
}
inline void DAC::set_index(int index, float value) {
  _internal_mutable_index()->Set(index, value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.index)
}
inline void DAC::add_index(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_index()->Add(value);
  // @@protoc_insertion_point(field_add:Union.AScan.Proto.DAC.index)
}
inline const ::google::protobuf::RepeatedField<float>& DAC::index() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Union.AScan.Proto.DAC.index)
  return _internal_index();
}
inline ::google::protobuf::RepeatedField<float>* DAC::mutable_index()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Union.AScan.Proto.DAC.index)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_index();
}
inline const ::google::protobuf::RepeatedField<float>&
DAC::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.index_;
}
inline ::google::protobuf::RepeatedField<float>* DAC::_internal_mutable_index() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.index_;
}

// repeated float value = 4;
inline int DAC::_internal_value_size() const {
  return _internal_value().size();
}
inline int DAC::value_size() const {
  return _internal_value_size();
}
inline void DAC::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Clear();
}
inline float DAC::value(int index) const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.value)
  return _internal_value().Get(index);
}
inline void DAC::set_value(int index, float value) {
  _internal_mutable_value()->Set(index, value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.value)
}
inline void DAC::add_value(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_value()->Add(value);
  // @@protoc_insertion_point(field_add:Union.AScan.Proto.DAC.value)
}
inline const ::google::protobuf::RepeatedField<float>& DAC::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Union.AScan.Proto.DAC.value)
  return _internal_value();
}
inline ::google::protobuf::RepeatedField<float>* DAC::mutable_value()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Union.AScan.Proto.DAC.value)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_value();
}
inline const ::google::protobuf::RepeatedField<float>&
DAC::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline ::google::protobuf::RepeatedField<float>* DAC::_internal_mutable_value() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.value_;
}

// float equivalent = 5;
inline void DAC::clear_equivalent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.equivalent_ = 0;
}
inline float DAC::equivalent() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.equivalent)
  return _internal_equivalent();
}
inline void DAC::set_equivalent(float value) {
  _internal_set_equivalent(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.equivalent)
}
inline float DAC::_internal_equivalent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.equivalent_;
}
inline void DAC::_internal_set_equivalent(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.equivalent_ = value;
}

// .Union.AScan.Proto.DACCriteria criteria = 6;
inline void DAC::clear_criteria() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.criteria_ = 0;
}
inline ::Union::AScan::Proto::DACCriteria DAC::criteria() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.criteria)
  return _internal_criteria();
}
inline void DAC::set_criteria(::Union::AScan::Proto::DACCriteria value) {
  _internal_set_criteria(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.criteria)
}
inline ::Union::AScan::Proto::DACCriteria DAC::_internal_criteria() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::Union::AScan::Proto::DACCriteria>(_impl_.criteria_);
}
inline void DAC::_internal_set_criteria(::Union::AScan::Proto::DACCriteria value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.criteria_ = value;
}

// optional .Union.AScan.Proto.DACCriteriaBias criteriaBias = 7;
inline bool DAC::has_criteriabias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.criteriabias_ != nullptr);
  return value;
}
inline void DAC::clear_criteriabias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.criteriabias_ != nullptr) _impl_.criteriabias_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Union::AScan::Proto::DACCriteriaBias& DAC::_internal_criteriabias() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Union::AScan::Proto::DACCriteriaBias* p = _impl_.criteriabias_;
  return p != nullptr ? *p : reinterpret_cast<const ::Union::AScan::Proto::DACCriteriaBias&>(::Union::AScan::Proto::_DACCriteriaBias_default_instance_);
}
inline const ::Union::AScan::Proto::DACCriteriaBias& DAC::criteriabias() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.criteriaBias)
  return _internal_criteriabias();
}
inline void DAC::unsafe_arena_set_allocated_criteriabias(::Union::AScan::Proto::DACCriteriaBias* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.criteriabias_);
  }
  _impl_.criteriabias_ = reinterpret_cast<::Union::AScan::Proto::DACCriteriaBias*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Union.AScan.Proto.DAC.criteriaBias)
}
inline ::Union::AScan::Proto::DACCriteriaBias* DAC::release_criteriabias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Union::AScan::Proto::DACCriteriaBias* released = _impl_.criteriabias_;
  _impl_.criteriabias_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Union::AScan::Proto::DACCriteriaBias* DAC::unsafe_arena_release_criteriabias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.DAC.criteriaBias)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Union::AScan::Proto::DACCriteriaBias* temp = _impl_.criteriabias_;
  _impl_.criteriabias_ = nullptr;
  return temp;
}
inline ::Union::AScan::Proto::DACCriteriaBias* DAC::_internal_mutable_criteriabias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.criteriabias_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Union::AScan::Proto::DACCriteriaBias>(GetArena());
    _impl_.criteriabias_ = reinterpret_cast<::Union::AScan::Proto::DACCriteriaBias*>(p);
  }
  return _impl_.criteriabias_;
}
inline ::Union::AScan::Proto::DACCriteriaBias* DAC::mutable_criteriabias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Union::AScan::Proto::DACCriteriaBias* _msg = _internal_mutable_criteriabias();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.DAC.criteriaBias)
  return _msg;
}
inline void DAC::set_allocated_criteriabias(::Union::AScan::Proto::DACCriteriaBias* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.criteriabias_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.criteriabias_ = reinterpret_cast<::Union::AScan::Proto::DACCriteriaBias*>(value);
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.DAC.criteriaBias)
}

// bool isSubLine = 8;
inline void DAC::clear_issubline() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.issubline_ = false;
}
inline bool DAC::issubline() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.isSubLine)
  return _internal_issubline();
}
inline void DAC::set_issubline(bool value) {
  _internal_set_issubline(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.isSubLine)
}
inline bool DAC::_internal_issubline() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.issubline_;
}
inline void DAC::_internal_set_issubline(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.issubline_ = value;
}

// float samplingXAxisBias = 9;
inline void DAC::clear_samplingxaxisbias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.samplingxaxisbias_ = 0;
}
inline float DAC::samplingxaxisbias() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.samplingXAxisBias)
  return _internal_samplingxaxisbias();
}
inline void DAC::set_samplingxaxisbias(float value) {
  _internal_set_samplingxaxisbias(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.samplingXAxisBias)
}
inline float DAC::_internal_samplingxaxisbias() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.samplingxaxisbias_;
}
inline void DAC::_internal_set_samplingxaxisbias(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.samplingxaxisbias_ = value;
}

// float samplingXAxisLen = 10;
inline void DAC::clear_samplingxaxislen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.samplingxaxislen_ = 0;
}
inline float DAC::samplingxaxislen() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.samplingXAxisLen)
  return _internal_samplingxaxislen();
}
inline void DAC::set_samplingxaxislen(float value) {
  _internal_set_samplingxaxislen(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.samplingXAxisLen)
}
inline float DAC::_internal_samplingxaxislen() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.samplingxaxislen_;
}
inline void DAC::_internal_set_samplingxaxislen(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.samplingxaxislen_ = value;
}

// -------------------------------------------------------------------

// AVG

// float baseGain = 1;
inline void AVG::clear_basegain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.basegain_ = 0;
}
inline float AVG::basegain() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.baseGain)
  return _internal_basegain();
}
inline void AVG::set_basegain(float value) {
  _internal_set_basegain(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.baseGain)
}
inline float AVG::_internal_basegain() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.basegain_;
}
inline void AVG::_internal_set_basegain(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.basegain_ = value;
}

// float compensatingGain = 2;
inline void AVG::clear_compensatinggain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compensatinggain_ = 0;
}
inline float AVG::compensatinggain() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.compensatingGain)
  return _internal_compensatinggain();
}
inline void AVG::set_compensatinggain(float value) {
  _internal_set_compensatinggain(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.compensatingGain)
}
inline float AVG::_internal_compensatinggain() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.compensatinggain_;
}
inline void AVG::_internal_set_compensatinggain(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compensatinggain_ = value;
}

// float scanGain = 3;
inline void AVG::clear_scangain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scangain_ = 0;
}
inline float AVG::scangain() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.scanGain)
  return _internal_scangain();
}
inline void AVG::set_scangain(float value) {
  _internal_set_scangain(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.scanGain)
}
inline float AVG::_internal_scangain() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.scangain_;
}
inline void AVG::_internal_set_scangain(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scangain_ = value;
}

// repeated float index = 4;
inline int AVG::_internal_index_size() const {
  return _internal_index().size();
}
inline int AVG::index_size() const {
  return _internal_index_size();
}
inline void AVG::clear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_.Clear();
}
inline float AVG::index(int index) const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.index)
  return _internal_index().Get(index);
}
inline void AVG::set_index(int index, float value) {
  _internal_mutable_index()->Set(index, value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.index)
}
inline void AVG::add_index(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_index()->Add(value);
  // @@protoc_insertion_point(field_add:Union.AScan.Proto.AVG.index)
}
inline const ::google::protobuf::RepeatedField<float>& AVG::index() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Union.AScan.Proto.AVG.index)
  return _internal_index();
}
inline ::google::protobuf::RepeatedField<float>* AVG::mutable_index()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Union.AScan.Proto.AVG.index)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_index();
}
inline const ::google::protobuf::RepeatedField<float>&
AVG::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.index_;
}
inline ::google::protobuf::RepeatedField<float>* AVG::_internal_mutable_index() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.index_;
}

// repeated float value = 5;
inline int AVG::_internal_value_size() const {
  return _internal_value().size();
}
inline int AVG::value_size() const {
  return _internal_value_size();
}
inline void AVG::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Clear();
}
inline float AVG::value(int index) const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.value)
  return _internal_value().Get(index);
}
inline void AVG::set_value(int index, float value) {
  _internal_mutable_value()->Set(index, value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.value)
}
inline void AVG::add_value(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_value()->Add(value);
  // @@protoc_insertion_point(field_add:Union.AScan.Proto.AVG.value)
}
inline const ::google::protobuf::RepeatedField<float>& AVG::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Union.AScan.Proto.AVG.value)
  return _internal_value();
}
inline ::google::protobuf::RepeatedField<float>* AVG::mutable_value()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Union.AScan.Proto.AVG.value)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_value();
}
inline const ::google::protobuf::RepeatedField<float>&
AVG::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline ::google::protobuf::RepeatedField<float>* AVG::_internal_mutable_value() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.value_;
}

// bool isSubLine = 6;
inline void AVG::clear_issubline() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.issubline_ = false;
}
inline bool AVG::issubline() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.isSubLine)
  return _internal_issubline();
}
inline void AVG::set_issubline(bool value) {
  _internal_set_issubline(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.isSubLine)
}
inline bool AVG::_internal_issubline() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.issubline_;
}
inline void AVG::_internal_set_issubline(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.issubline_ = value;
}

// float samplingXAxisBias = 7;
inline void AVG::clear_samplingxaxisbias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.samplingxaxisbias_ = 0;
}
inline float AVG::samplingxaxisbias() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.samplingXAxisBias)
  return _internal_samplingxaxisbias();
}
inline void AVG::set_samplingxaxisbias(float value) {
  _internal_set_samplingxaxisbias(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.samplingXAxisBias)
}
inline float AVG::_internal_samplingxaxisbias() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.samplingxaxisbias_;
}
inline void AVG::_internal_set_samplingxaxisbias(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.samplingxaxisbias_ = value;
}

// float samplingXAxisLen = 8;
inline void AVG::clear_samplingxaxislen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.samplingxaxislen_ = 0;
}
inline float AVG::samplingxaxislen() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.samplingXAxisLen)
  return _internal_samplingxaxislen();
}
inline void AVG::set_samplingxaxislen(float value) {
  _internal_set_samplingxaxislen(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.samplingXAxisLen)
}
inline float AVG::_internal_samplingxaxislen() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.samplingxaxislen_;
}
inline void AVG::_internal_set_samplingxaxislen(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.samplingxaxislen_ = value;
}

// float diameter = 9;
inline void AVG::clear_diameter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.diameter_ = 0;
}
inline float AVG::diameter() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.diameter)
  return _internal_diameter();
}
inline void AVG::set_diameter(float value) {
  _internal_set_diameter(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.diameter)
}
inline float AVG::_internal_diameter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.diameter_;
}
inline void AVG::_internal_set_diameter(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.diameter_ = value;
}

// float reflectorDiameter = 10;
inline void AVG::clear_reflectordiameter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reflectordiameter_ = 0;
}
inline float AVG::reflectordiameter() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.reflectorDiameter)
  return _internal_reflectordiameter();
}
inline void AVG::set_reflectordiameter(float value) {
  _internal_set_reflectordiameter(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.reflectorDiameter)
}
inline float AVG::_internal_reflectordiameter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reflectordiameter_;
}
inline void AVG::_internal_set_reflectordiameter(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reflectordiameter_ = value;
}

// float reflectorMaxDepth = 11;
inline void AVG::clear_reflectormaxdepth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reflectormaxdepth_ = 0;
}
inline float AVG::reflectormaxdepth() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.reflectorMaxDepth)
  return _internal_reflectormaxdepth();
}
inline void AVG::set_reflectormaxdepth(float value) {
  _internal_set_reflectormaxdepth(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.reflectorMaxDepth)
}
inline float AVG::_internal_reflectormaxdepth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reflectormaxdepth_;
}
inline void AVG::_internal_set_reflectormaxdepth(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reflectormaxdepth_ = value;
}

// float equivalent = 12;
inline void AVG::clear_equivalent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.equivalent_ = 0;
}
inline float AVG::equivalent() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.equivalent)
  return _internal_equivalent();
}
inline void AVG::set_equivalent(float value) {
  _internal_set_equivalent(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.equivalent)
}
inline float AVG::_internal_equivalent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.equivalent_;
}
inline void AVG::_internal_set_equivalent(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.equivalent_ = value;
}

// -------------------------------------------------------------------

// InstrumentParameter

// .Union.AScan.Proto.Probe probe = 3;
inline void InstrumentParameter::clear_probe() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.probe_ = 0;
}
inline ::Union::AScan::Proto::Probe InstrumentParameter::probe() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.probe)
  return _internal_probe();
}
inline void InstrumentParameter::set_probe(::Union::AScan::Proto::Probe value) {
  _internal_set_probe(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.probe)
}
inline ::Union::AScan::Proto::Probe InstrumentParameter::_internal_probe() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::Union::AScan::Proto::Probe>(_impl_.probe_);
}
inline void InstrumentParameter::_internal_set_probe(::Union::AScan::Proto::Probe value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.probe_ = value;
}

// float probeFrequence = 4;
inline void InstrumentParameter::clear_probefrequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.probefrequence_ = 0;
}
inline float InstrumentParameter::probefrequence() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.probeFrequence)
  return _internal_probefrequence();
}
inline void InstrumentParameter::set_probefrequence(float value) {
  _internal_set_probefrequence(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.probeFrequence)
}
inline float InstrumentParameter::_internal_probefrequence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.probefrequence_;
}
inline void InstrumentParameter::_internal_set_probefrequence(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.probefrequence_ = value;
}

// float probeChipShapeL = 5;
inline void InstrumentParameter::clear_probechipshapel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.probechipshapel_ = 0;
}
inline float InstrumentParameter::probechipshapel() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.probeChipShapeL)
  return _internal_probechipshapel();
}
inline void InstrumentParameter::set_probechipshapel(float value) {
  _internal_set_probechipshapel(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.probeChipShapeL)
}
inline float InstrumentParameter::_internal_probechipshapel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.probechipshapel_;
}
inline void InstrumentParameter::_internal_set_probechipshapel(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.probechipshapel_ = value;
}

// float probeChipShapeH = 6;
inline void InstrumentParameter::clear_probechipshapeh() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.probechipshapeh_ = 0;
}
inline float InstrumentParameter::probechipshapeh() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.probeChipShapeH)
  return _internal_probechipshapeh();
}
inline void InstrumentParameter::set_probechipshapeh(float value) {
  _internal_set_probechipshapeh(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.probeChipShapeH)
}
inline float InstrumentParameter::_internal_probechipshapeh() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.probechipshapeh_;
}
inline void InstrumentParameter::_internal_set_probechipshapeh(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.probechipshapeh_ = value;
}

// float angle = 7;
inline void InstrumentParameter::clear_angle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.angle_ = 0;
}
inline float InstrumentParameter::angle() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.angle)
  return _internal_angle();
}
inline void InstrumentParameter::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.angle)
}
inline float InstrumentParameter::_internal_angle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.angle_;
}
inline void InstrumentParameter::_internal_set_angle(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.angle_ = value;
}

// float soundVelocity = 8;
inline void InstrumentParameter::clear_soundvelocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.soundvelocity_ = 0;
}
inline float InstrumentParameter::soundvelocity() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.soundVelocity)
  return _internal_soundvelocity();
}
inline void InstrumentParameter::set_soundvelocity(float value) {
  _internal_set_soundvelocity(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.soundVelocity)
}
inline float InstrumentParameter::_internal_soundvelocity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.soundvelocity_;
}
inline void InstrumentParameter::_internal_set_soundvelocity(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.soundvelocity_ = value;
}

// float probeFrontDistance = 9;
inline void InstrumentParameter::clear_probefrontdistance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.probefrontdistance_ = 0;
}
inline float InstrumentParameter::probefrontdistance() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.probeFrontDistance)
  return _internal_probefrontdistance();
}
inline void InstrumentParameter::set_probefrontdistance(float value) {
  _internal_set_probefrontdistance(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.probeFrontDistance)
}
inline float InstrumentParameter::_internal_probefrontdistance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.probefrontdistance_;
}
inline void InstrumentParameter::_internal_set_probefrontdistance(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.probefrontdistance_ = value;
}

// float zeroPoint = 10;
inline void InstrumentParameter::clear_zeropoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zeropoint_ = 0;
}
inline float InstrumentParameter::zeropoint() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.zeroPoint)
  return _internal_zeropoint();
}
inline void InstrumentParameter::set_zeropoint(float value) {
  _internal_set_zeropoint(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.zeroPoint)
}
inline float InstrumentParameter::_internal_zeropoint() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.zeropoint_;
}
inline void InstrumentParameter::_internal_set_zeropoint(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zeropoint_ = value;
}

// int32 channel = 11;
inline void InstrumentParameter::clear_channel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_ = 0;
}
inline ::int32_t InstrumentParameter::channel() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.channel)
  return _internal_channel();
}
inline void InstrumentParameter::set_channel(::int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.channel)
}
inline ::int32_t InstrumentParameter::_internal_channel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_;
}
inline void InstrumentParameter::_internal_set_channel(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_ = value;
}

// optional .Union.AScan.Proto.Performance performance = 12;
inline bool InstrumentParameter::has_performance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.performance_ != nullptr);
  return value;
}
inline void InstrumentParameter::clear_performance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.performance_ != nullptr) _impl_.performance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Union::AScan::Proto::Performance& InstrumentParameter::_internal_performance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Union::AScan::Proto::Performance* p = _impl_.performance_;
  return p != nullptr ? *p : reinterpret_cast<const ::Union::AScan::Proto::Performance&>(::Union::AScan::Proto::_Performance_default_instance_);
}
inline const ::Union::AScan::Proto::Performance& InstrumentParameter::performance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.performance)
  return _internal_performance();
}
inline void InstrumentParameter::unsafe_arena_set_allocated_performance(::Union::AScan::Proto::Performance* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.performance_);
  }
  _impl_.performance_ = reinterpret_cast<::Union::AScan::Proto::Performance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Union.AScan.Proto.InstrumentParameter.performance)
}
inline ::Union::AScan::Proto::Performance* InstrumentParameter::release_performance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Union::AScan::Proto::Performance* released = _impl_.performance_;
  _impl_.performance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Union::AScan::Proto::Performance* InstrumentParameter::unsafe_arena_release_performance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.InstrumentParameter.performance)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Union::AScan::Proto::Performance* temp = _impl_.performance_;
  _impl_.performance_ = nullptr;
  return temp;
}
inline ::Union::AScan::Proto::Performance* InstrumentParameter::_internal_mutable_performance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.performance_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Union::AScan::Proto::Performance>(GetArena());
    _impl_.performance_ = reinterpret_cast<::Union::AScan::Proto::Performance*>(p);
  }
  return _impl_.performance_;
}
inline ::Union::AScan::Proto::Performance* InstrumentParameter::mutable_performance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Union::AScan::Proto::Performance* _msg = _internal_mutable_performance();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.InstrumentParameter.performance)
  return _msg;
}
inline void InstrumentParameter::set_allocated_performance(::Union::AScan::Proto::Performance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.performance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.performance_ = reinterpret_cast<::Union::AScan::Proto::Performance*>(value);
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.InstrumentParameter.performance)
}

// -------------------------------------------------------------------

// ChannelParameter

// repeated .Union.AScan.Proto.Gate gate = 1;
inline int ChannelParameter::_internal_gate_size() const {
  return _internal_gate().size();
}
inline int ChannelParameter::gate_size() const {
  return _internal_gate_size();
}
inline void ChannelParameter::clear_gate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gate_.Clear();
}
inline ::Union::AScan::Proto::Gate* ChannelParameter::mutable_gate(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.ChannelParameter.gate)
  return _internal_mutable_gate()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Union::AScan::Proto::Gate>* ChannelParameter::mutable_gate()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Union.AScan.Proto.ChannelParameter.gate)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_gate();
}
inline const ::Union::AScan::Proto::Gate& ChannelParameter::gate(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.gate)
  return _internal_gate().Get(index);
}
inline ::Union::AScan::Proto::Gate* ChannelParameter::add_gate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::Union::AScan::Proto::Gate* _add = _internal_mutable_gate()->Add();
  // @@protoc_insertion_point(field_add:Union.AScan.Proto.ChannelParameter.gate)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Union::AScan::Proto::Gate>& ChannelParameter::gate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Union.AScan.Proto.ChannelParameter.gate)
  return _internal_gate();
}
inline const ::google::protobuf::RepeatedPtrField<::Union::AScan::Proto::Gate>&
ChannelParameter::_internal_gate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gate_;
}
inline ::google::protobuf::RepeatedPtrField<::Union::AScan::Proto::Gate>*
ChannelParameter::_internal_mutable_gate() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.gate_;
}

// bytes ascan = 2;
inline void ChannelParameter::clear_ascan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ascan_.ClearToEmpty();
}
inline const std::string& ChannelParameter::ascan() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.ascan)
  return _internal_ascan();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelParameter::set_ascan(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ascan_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.ChannelParameter.ascan)
}
inline std::string* ChannelParameter::mutable_ascan() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ascan();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.ChannelParameter.ascan)
  return _s;
}
inline const std::string& ChannelParameter::_internal_ascan() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ascan_.Get();
}
inline void ChannelParameter::_internal_set_ascan(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ascan_.Set(value, GetArena());
}
inline std::string* ChannelParameter::_internal_mutable_ascan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ascan_.Mutable( GetArena());
}
inline std::string* ChannelParameter::release_ascan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.ChannelParameter.ascan)
  return _impl_.ascan_.Release();
}
inline void ChannelParameter::set_allocated_ascan(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ascan_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ascan_.IsDefault()) {
          _impl_.ascan_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.ChannelParameter.ascan)
}

// float axisBias = 3;
inline void ChannelParameter::clear_axisbias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.axisbias_ = 0;
}
inline float ChannelParameter::axisbias() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.axisBias)
  return _internal_axisbias();
}
inline void ChannelParameter::set_axisbias(float value) {
  _internal_set_axisbias(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.ChannelParameter.axisBias)
}
inline float ChannelParameter::_internal_axisbias() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.axisbias_;
}
inline void ChannelParameter::_internal_set_axisbias(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.axisbias_ = value;
}

// float axisLen = 4;
inline void ChannelParameter::clear_axislen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.axislen_ = 0;
}
inline float ChannelParameter::axislen() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.axisLen)
  return _internal_axislen();
}
inline void ChannelParameter::set_axislen(float value) {
  _internal_set_axislen(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.ChannelParameter.axisLen)
}
inline float ChannelParameter::_internal_axislen() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.axislen_;
}
inline void ChannelParameter::_internal_set_axislen(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.axislen_ = value;
}

// float baseGain = 5;
inline void ChannelParameter::clear_basegain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.basegain_ = 0;
}
inline float ChannelParameter::basegain() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.baseGain)
  return _internal_basegain();
}
inline void ChannelParameter::set_basegain(float value) {
  _internal_set_basegain(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.ChannelParameter.baseGain)
}
inline float ChannelParameter::_internal_basegain() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.basegain_;
}
inline void ChannelParameter::_internal_set_basegain(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.basegain_ = value;
}

// float scanGain = 6;
inline void ChannelParameter::clear_scangain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scangain_ = 0;
}
inline float ChannelParameter::scangain() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.scanGain)
  return _internal_scangain();
}
inline void ChannelParameter::set_scangain(float value) {
  _internal_set_scangain(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.ChannelParameter.scanGain)
}
inline float ChannelParameter::_internal_scangain() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.scangain_;
}
inline void ChannelParameter::_internal_set_scangain(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scangain_ = value;
}

// float compensatingGain = 7;
inline void ChannelParameter::clear_compensatinggain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compensatinggain_ = 0;
}
inline float ChannelParameter::compensatinggain() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.compensatingGain)
  return _internal_compensatinggain();
}
inline void ChannelParameter::set_compensatinggain(float value) {
  _internal_set_compensatinggain(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.ChannelParameter.compensatingGain)
}
inline float ChannelParameter::_internal_compensatinggain() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.compensatinggain_;
}
inline void ChannelParameter::_internal_set_compensatinggain(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compensatinggain_ = value;
}

// int32 suppression = 8;
inline void ChannelParameter::clear_suppression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.suppression_ = 0;
}
inline ::int32_t ChannelParameter::suppression() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.suppression)
  return _internal_suppression();
}
inline void ChannelParameter::set_suppression(::int32_t value) {
  _internal_set_suppression(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.ChannelParameter.suppression)
}
inline ::int32_t ChannelParameter::_internal_suppression() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.suppression_;
}
inline void ChannelParameter::_internal_set_suppression(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.suppression_ = value;
}

// .Union.AScan.Proto.DistanceMode distanceMode = 9;
inline void ChannelParameter::clear_distancemode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distancemode_ = 0;
}
inline ::Union::AScan::Proto::DistanceMode ChannelParameter::distancemode() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.distanceMode)
  return _internal_distancemode();
}
inline void ChannelParameter::set_distancemode(::Union::AScan::Proto::DistanceMode value) {
  _internal_set_distancemode(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.ChannelParameter.distanceMode)
}
inline ::Union::AScan::Proto::DistanceMode ChannelParameter::_internal_distancemode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::Union::AScan::Proto::DistanceMode>(_impl_.distancemode_);
}
inline void ChannelParameter::_internal_set_distancemode(::Union::AScan::Proto::DistanceMode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distancemode_ = value;
}

// optional .Union.AScan.Proto.DAC dac = 10;
inline bool ChannelParameter::has_dac() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dac_ != nullptr);
  return value;
}
inline void ChannelParameter::clear_dac() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dac_ != nullptr) _impl_.dac_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Union::AScan::Proto::DAC& ChannelParameter::_internal_dac() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Union::AScan::Proto::DAC* p = _impl_.dac_;
  return p != nullptr ? *p : reinterpret_cast<const ::Union::AScan::Proto::DAC&>(::Union::AScan::Proto::_DAC_default_instance_);
}
inline const ::Union::AScan::Proto::DAC& ChannelParameter::dac() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.dac)
  return _internal_dac();
}
inline void ChannelParameter::unsafe_arena_set_allocated_dac(::Union::AScan::Proto::DAC* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dac_);
  }
  _impl_.dac_ = reinterpret_cast<::Union::AScan::Proto::DAC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Union.AScan.Proto.ChannelParameter.dac)
}
inline ::Union::AScan::Proto::DAC* ChannelParameter::release_dac() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Union::AScan::Proto::DAC* released = _impl_.dac_;
  _impl_.dac_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Union::AScan::Proto::DAC* ChannelParameter::unsafe_arena_release_dac() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.ChannelParameter.dac)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Union::AScan::Proto::DAC* temp = _impl_.dac_;
  _impl_.dac_ = nullptr;
  return temp;
}
inline ::Union::AScan::Proto::DAC* ChannelParameter::_internal_mutable_dac() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dac_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Union::AScan::Proto::DAC>(GetArena());
    _impl_.dac_ = reinterpret_cast<::Union::AScan::Proto::DAC*>(p);
  }
  return _impl_.dac_;
}
inline ::Union::AScan::Proto::DAC* ChannelParameter::mutable_dac() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Union::AScan::Proto::DAC* _msg = _internal_mutable_dac();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.ChannelParameter.dac)
  return _msg;
}
inline void ChannelParameter::set_allocated_dac(::Union::AScan::Proto::DAC* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dac_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dac_ = reinterpret_cast<::Union::AScan::Proto::DAC*>(value);
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.ChannelParameter.dac)
}

// optional .Union.AScan.Proto.AVG avg = 11;
inline bool ChannelParameter::has_avg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.avg_ != nullptr);
  return value;
}
inline void ChannelParameter::clear_avg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.avg_ != nullptr) _impl_.avg_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Union::AScan::Proto::AVG& ChannelParameter::_internal_avg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Union::AScan::Proto::AVG* p = _impl_.avg_;
  return p != nullptr ? *p : reinterpret_cast<const ::Union::AScan::Proto::AVG&>(::Union::AScan::Proto::_AVG_default_instance_);
}
inline const ::Union::AScan::Proto::AVG& ChannelParameter::avg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.avg)
  return _internal_avg();
}
inline void ChannelParameter::unsafe_arena_set_allocated_avg(::Union::AScan::Proto::AVG* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.avg_);
  }
  _impl_.avg_ = reinterpret_cast<::Union::AScan::Proto::AVG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Union.AScan.Proto.ChannelParameter.avg)
}
inline ::Union::AScan::Proto::AVG* ChannelParameter::release_avg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Union::AScan::Proto::AVG* released = _impl_.avg_;
  _impl_.avg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Union::AScan::Proto::AVG* ChannelParameter::unsafe_arena_release_avg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.ChannelParameter.avg)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Union::AScan::Proto::AVG* temp = _impl_.avg_;
  _impl_.avg_ = nullptr;
  return temp;
}
inline ::Union::AScan::Proto::AVG* ChannelParameter::_internal_mutable_avg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.avg_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Union::AScan::Proto::AVG>(GetArena());
    _impl_.avg_ = reinterpret_cast<::Union::AScan::Proto::AVG*>(p);
  }
  return _impl_.avg_;
}
inline ::Union::AScan::Proto::AVG* ChannelParameter::mutable_avg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::Union::AScan::Proto::AVG* _msg = _internal_mutable_avg();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.ChannelParameter.avg)
  return _msg;
}
inline void ChannelParameter::set_allocated_avg(::Union::AScan::Proto::AVG* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.avg_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.avg_ = reinterpret_cast<::Union::AScan::Proto::AVG*>(value);
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.ChannelParameter.avg)
}

// optional .Union.AScan.Proto.Performance performance = 12;
inline bool ChannelParameter::has_performance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.performance_ != nullptr);
  return value;
}
inline void ChannelParameter::clear_performance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.performance_ != nullptr) _impl_.performance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::Union::AScan::Proto::Performance& ChannelParameter::_internal_performance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Union::AScan::Proto::Performance* p = _impl_.performance_;
  return p != nullptr ? *p : reinterpret_cast<const ::Union::AScan::Proto::Performance&>(::Union::AScan::Proto::_Performance_default_instance_);
}
inline const ::Union::AScan::Proto::Performance& ChannelParameter::performance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.performance)
  return _internal_performance();
}
inline void ChannelParameter::unsafe_arena_set_allocated_performance(::Union::AScan::Proto::Performance* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.performance_);
  }
  _impl_.performance_ = reinterpret_cast<::Union::AScan::Proto::Performance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Union.AScan.Proto.ChannelParameter.performance)
}
inline ::Union::AScan::Proto::Performance* ChannelParameter::release_performance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Union::AScan::Proto::Performance* released = _impl_.performance_;
  _impl_.performance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Union::AScan::Proto::Performance* ChannelParameter::unsafe_arena_release_performance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.ChannelParameter.performance)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Union::AScan::Proto::Performance* temp = _impl_.performance_;
  _impl_.performance_ = nullptr;
  return temp;
}
inline ::Union::AScan::Proto::Performance* ChannelParameter::_internal_mutable_performance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.performance_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Union::AScan::Proto::Performance>(GetArena());
    _impl_.performance_ = reinterpret_cast<::Union::AScan::Proto::Performance*>(p);
  }
  return _impl_.performance_;
}
inline ::Union::AScan::Proto::Performance* ChannelParameter::mutable_performance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::Union::AScan::Proto::Performance* _msg = _internal_mutable_performance();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.ChannelParameter.performance)
  return _msg;
}
inline void ChannelParameter::set_allocated_performance(::Union::AScan::Proto::Performance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.performance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.performance_ = reinterpret_cast<::Union::AScan::Proto::Performance*>(value);
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.ChannelParameter.performance)
}

// -------------------------------------------------------------------

// AScanPayload

// .Union.AScan.Proto.InstrumentParameter instrumentParameter = 1;
inline bool AScanPayload::has_instrumentparameter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.instrumentparameter_ != nullptr);
  return value;
}
inline void AScanPayload::clear_instrumentparameter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.instrumentparameter_ != nullptr) _impl_.instrumentparameter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Union::AScan::Proto::InstrumentParameter& AScanPayload::_internal_instrumentparameter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Union::AScan::Proto::InstrumentParameter* p = _impl_.instrumentparameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::Union::AScan::Proto::InstrumentParameter&>(::Union::AScan::Proto::_InstrumentParameter_default_instance_);
}
inline const ::Union::AScan::Proto::InstrumentParameter& AScanPayload::instrumentparameter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AScanPayload.instrumentParameter)
  return _internal_instrumentparameter();
}
inline void AScanPayload::unsafe_arena_set_allocated_instrumentparameter(::Union::AScan::Proto::InstrumentParameter* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.instrumentparameter_);
  }
  _impl_.instrumentparameter_ = reinterpret_cast<::Union::AScan::Proto::InstrumentParameter*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Union.AScan.Proto.AScanPayload.instrumentParameter)
}
inline ::Union::AScan::Proto::InstrumentParameter* AScanPayload::release_instrumentparameter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Union::AScan::Proto::InstrumentParameter* released = _impl_.instrumentparameter_;
  _impl_.instrumentparameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Union::AScan::Proto::InstrumentParameter* AScanPayload::unsafe_arena_release_instrumentparameter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.AScanPayload.instrumentParameter)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Union::AScan::Proto::InstrumentParameter* temp = _impl_.instrumentparameter_;
  _impl_.instrumentparameter_ = nullptr;
  return temp;
}
inline ::Union::AScan::Proto::InstrumentParameter* AScanPayload::_internal_mutable_instrumentparameter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.instrumentparameter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Union::AScan::Proto::InstrumentParameter>(GetArena());
    _impl_.instrumentparameter_ = reinterpret_cast<::Union::AScan::Proto::InstrumentParameter*>(p);
  }
  return _impl_.instrumentparameter_;
}
inline ::Union::AScan::Proto::InstrumentParameter* AScanPayload::mutable_instrumentparameter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::Union::AScan::Proto::InstrumentParameter* _msg = _internal_mutable_instrumentparameter();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.AScanPayload.instrumentParameter)
  return _msg;
}
inline void AScanPayload::set_allocated_instrumentparameter(::Union::AScan::Proto::InstrumentParameter* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.instrumentparameter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.instrumentparameter_ = reinterpret_cast<::Union::AScan::Proto::InstrumentParameter*>(value);
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.AScanPayload.instrumentParameter)
}

// .Union.AScan.Proto.ChannelParameter channelParameter = 2;
inline bool AScanPayload::has_channelparameter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.channelparameter_ != nullptr);
  return value;
}
inline void AScanPayload::clear_channelparameter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.channelparameter_ != nullptr) _impl_.channelparameter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::Union::AScan::Proto::ChannelParameter& AScanPayload::_internal_channelparameter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Union::AScan::Proto::ChannelParameter* p = _impl_.channelparameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::Union::AScan::Proto::ChannelParameter&>(::Union::AScan::Proto::_ChannelParameter_default_instance_);
}
inline const ::Union::AScan::Proto::ChannelParameter& AScanPayload::channelparameter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AScanPayload.channelParameter)
  return _internal_channelparameter();
}
inline void AScanPayload::unsafe_arena_set_allocated_channelparameter(::Union::AScan::Proto::ChannelParameter* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.channelparameter_);
  }
  _impl_.channelparameter_ = reinterpret_cast<::Union::AScan::Proto::ChannelParameter*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Union.AScan.Proto.AScanPayload.channelParameter)
}
inline ::Union::AScan::Proto::ChannelParameter* AScanPayload::release_channelparameter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Union::AScan::Proto::ChannelParameter* released = _impl_.channelparameter_;
  _impl_.channelparameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Union::AScan::Proto::ChannelParameter* AScanPayload::unsafe_arena_release_channelparameter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.AScanPayload.channelParameter)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Union::AScan::Proto::ChannelParameter* temp = _impl_.channelparameter_;
  _impl_.channelparameter_ = nullptr;
  return temp;
}
inline ::Union::AScan::Proto::ChannelParameter* AScanPayload::_internal_mutable_channelparameter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.channelparameter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Union::AScan::Proto::ChannelParameter>(GetArena());
    _impl_.channelparameter_ = reinterpret_cast<::Union::AScan::Proto::ChannelParameter*>(p);
  }
  return _impl_.channelparameter_;
}
inline ::Union::AScan::Proto::ChannelParameter* AScanPayload::mutable_channelparameter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::Union::AScan::Proto::ChannelParameter* _msg = _internal_mutable_channelparameter();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.AScanPayload.channelParameter)
  return _msg;
}
inline void AScanPayload::set_allocated_channelparameter(::Union::AScan::Proto::ChannelParameter* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.channelparameter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.channelparameter_ = reinterpret_cast<::Union::AScan::Proto::ChannelParameter*>(value);
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.AScanPayload.channelParameter)
}

// optional bytes cameraData = 3;
inline bool AScanPayload::has_cameradata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AScanPayload::clear_cameradata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cameradata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AScanPayload::cameradata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AScanPayload.cameraData)
  return _internal_cameradata();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AScanPayload::set_cameradata(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cameradata_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AScanPayload.cameraData)
}
inline std::string* AScanPayload::mutable_cameradata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cameradata();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.AScanPayload.cameraData)
  return _s;
}
inline const std::string& AScanPayload::_internal_cameradata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cameradata_.Get();
}
inline void AScanPayload::_internal_set_cameradata(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cameradata_.Set(value, GetArena());
}
inline std::string* AScanPayload::_internal_mutable_cameradata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.cameradata_.Mutable( GetArena());
}
inline std::string* AScanPayload::release_cameradata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.AScanPayload.cameraData)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.cameradata_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cameradata_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AScanPayload::set_allocated_cameradata(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cameradata_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cameradata_.IsDefault()) {
          _impl_.cameradata_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.AScanPayload.cameraData)
}

// -------------------------------------------------------------------

// AScanHead

// string instrumentName = 1;
inline void AScanHead::clear_instrumentname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.instrumentname_.ClearToEmpty();
}
inline const std::string& AScanHead::instrumentname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AScanHead.instrumentName)
  return _internal_instrumentname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AScanHead::set_instrumentname(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.instrumentname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AScanHead.instrumentName)
}
inline std::string* AScanHead::mutable_instrumentname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_instrumentname();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.AScanHead.instrumentName)
  return _s;
}
inline const std::string& AScanHead::_internal_instrumentname() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.instrumentname_.Get();
}
inline void AScanHead::_internal_set_instrumentname(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.instrumentname_.Set(value, GetArena());
}
inline std::string* AScanHead::_internal_mutable_instrumentname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.instrumentname_.Mutable( GetArena());
}
inline std::string* AScanHead::release_instrumentname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.AScanHead.instrumentName)
  return _impl_.instrumentname_.Release();
}
inline void AScanHead::set_allocated_instrumentname(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.instrumentname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.instrumentname_.IsDefault()) {
          _impl_.instrumentname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.AScanHead.instrumentName)
}

// string time = 2;
inline void AScanHead::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_.ClearToEmpty();
}
inline const std::string& AScanHead::time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AScanHead.time)
  return _internal_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AScanHead::set_time(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AScanHead.time)
}
inline std::string* AScanHead::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.AScanHead.time)
  return _s;
}
inline const std::string& AScanHead::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_.Get();
}
inline void AScanHead::_internal_set_time(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_.Set(value, GetArena());
}
inline std::string* AScanHead::_internal_mutable_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.time_.Mutable( GetArena());
}
inline std::string* AScanHead::release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.AScanHead.time)
  return _impl_.time_.Release();
}
inline void AScanHead::set_allocated_time(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.time_.IsDefault()) {
          _impl_.time_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.AScanHead.time)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace Proto
}  // namespace AScan
}  // namespace Union


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::Union::AScan::Proto::Probe> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Union::AScan::Proto::Probe>() {
  return ::Union::AScan::Proto::Probe_descriptor();
}
template <>
struct is_proto_enum<::Union::AScan::Proto::DACCriteria> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Union::AScan::Proto::DACCriteria>() {
  return ::Union::AScan::Proto::DACCriteria_descriptor();
}
template <>
struct is_proto_enum<::Union::AScan::Proto::DistanceMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Union::AScan::Proto::DistanceMode>() {
  return ::Union::AScan::Proto::DistanceMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_AScan_2eproto_2epb_2eh
