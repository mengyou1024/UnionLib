// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AScan.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_AScan_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_AScan_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_AScan_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_AScan_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_AScan_2eproto;
namespace Union {
namespace AScan {
namespace Proto {
class AScanHead;
struct AScanHeadDefaultTypeInternal;
extern AScanHeadDefaultTypeInternal _AScanHead_default_instance_;
class AScanPayload;
struct AScanPayloadDefaultTypeInternal;
extern AScanPayloadDefaultTypeInternal _AScanPayload_default_instance_;
class AScanProtoType;
struct AScanProtoTypeDefaultTypeInternal;
extern AScanProtoTypeDefaultTypeInternal _AScanProtoType_default_instance_;
class AVG;
struct AVGDefaultTypeInternal;
extern AVGDefaultTypeInternal _AVG_default_instance_;
class ChannelParameter;
struct ChannelParameterDefaultTypeInternal;
extern ChannelParameterDefaultTypeInternal _ChannelParameter_default_instance_;
class DAC;
struct DACDefaultTypeInternal;
extern DACDefaultTypeInternal _DAC_default_instance_;
class DACCriteriaBias;
struct DACCriteriaBiasDefaultTypeInternal;
extern DACCriteriaBiasDefaultTypeInternal _DACCriteriaBias_default_instance_;
class Gate;
struct GateDefaultTypeInternal;
extern GateDefaultTypeInternal _Gate_default_instance_;
class InstrumentParameter;
struct InstrumentParameterDefaultTypeInternal;
extern InstrumentParameterDefaultTypeInternal _InstrumentParameter_default_instance_;
class Performance;
struct PerformanceDefaultTypeInternal;
extern PerformanceDefaultTypeInternal _Performance_default_instance_;
}  // namespace Proto
}  // namespace AScan
}  // namespace Union
PROTOBUF_NAMESPACE_OPEN
template<> ::Union::AScan::Proto::AScanHead* Arena::CreateMaybeMessage<::Union::AScan::Proto::AScanHead>(Arena*);
template<> ::Union::AScan::Proto::AScanPayload* Arena::CreateMaybeMessage<::Union::AScan::Proto::AScanPayload>(Arena*);
template<> ::Union::AScan::Proto::AScanProtoType* Arena::CreateMaybeMessage<::Union::AScan::Proto::AScanProtoType>(Arena*);
template<> ::Union::AScan::Proto::AVG* Arena::CreateMaybeMessage<::Union::AScan::Proto::AVG>(Arena*);
template<> ::Union::AScan::Proto::ChannelParameter* Arena::CreateMaybeMessage<::Union::AScan::Proto::ChannelParameter>(Arena*);
template<> ::Union::AScan::Proto::DAC* Arena::CreateMaybeMessage<::Union::AScan::Proto::DAC>(Arena*);
template<> ::Union::AScan::Proto::DACCriteriaBias* Arena::CreateMaybeMessage<::Union::AScan::Proto::DACCriteriaBias>(Arena*);
template<> ::Union::AScan::Proto::Gate* Arena::CreateMaybeMessage<::Union::AScan::Proto::Gate>(Arena*);
template<> ::Union::AScan::Proto::InstrumentParameter* Arena::CreateMaybeMessage<::Union::AScan::Proto::InstrumentParameter>(Arena*);
template<> ::Union::AScan::Proto::Performance* Arena::CreateMaybeMessage<::Union::AScan::Proto::Performance>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Union {
namespace AScan {
namespace Proto {

enum Probe : int {
  NormalProbe = 0,
  ObliqueProbe = 1,
  TwinCrystalLongitudinalWaveNormalprobe = 2,
  PenetrationProbe = 3,
  TwinCrystaLongitudinalWaveObliqueProbe = 4,
  Probe_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Probe_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Probe_IsValid(int value);
constexpr Probe Probe_MIN = NormalProbe;
constexpr Probe Probe_MAX = TwinCrystaLongitudinalWaveObliqueProbe;
constexpr int Probe_ARRAYSIZE = Probe_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Probe_descriptor();
template<typename T>
inline const std::string& Probe_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Probe>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Probe_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Probe_descriptor(), enum_t_value);
}
inline bool Probe_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Probe* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Probe>(
    Probe_descriptor(), name, value);
}
enum DACCriteria : int {
  None = 0,
  RL = 1,
  SL = 2,
  EL = 3,
  DACCriteria_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DACCriteria_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DACCriteria_IsValid(int value);
constexpr DACCriteria DACCriteria_MIN = None;
constexpr DACCriteria DACCriteria_MAX = EL;
constexpr int DACCriteria_ARRAYSIZE = DACCriteria_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DACCriteria_descriptor();
template<typename T>
inline const std::string& DACCriteria_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DACCriteria>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DACCriteria_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DACCriteria_descriptor(), enum_t_value);
}
inline bool DACCriteria_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DACCriteria* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DACCriteria>(
    DACCriteria_descriptor(), name, value);
}
enum DistanceMode : int {
  Y = 0,
  X = 1,
  S = 2,
  DistanceMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DistanceMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DistanceMode_IsValid(int value);
constexpr DistanceMode DistanceMode_MIN = Y;
constexpr DistanceMode DistanceMode_MAX = S;
constexpr int DistanceMode_ARRAYSIZE = DistanceMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DistanceMode_descriptor();
template<typename T>
inline const std::string& DistanceMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DistanceMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DistanceMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DistanceMode_descriptor(), enum_t_value);
}
inline bool DistanceMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DistanceMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DistanceMode>(
    DistanceMode_descriptor(), name, value);
}
// ===================================================================

class Performance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Union.AScan.Proto.Performance) */ {
 public:
  inline Performance() : Performance(nullptr) {}
  ~Performance() override;
  explicit PROTOBUF_CONSTEXPR Performance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Performance(const Performance& from);
  Performance(Performance&& from) noexcept
    : Performance() {
    *this = ::std::move(from);
  }

  inline Performance& operator=(const Performance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Performance& operator=(Performance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Performance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Performance* internal_default_instance() {
    return reinterpret_cast<const Performance*>(
               &_Performance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Performance& a, Performance& b) {
    a.Swap(&b);
  }
  inline void Swap(Performance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Performance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Performance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Performance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Performance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Performance& from) {
    Performance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Performance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Union.AScan.Proto.Performance";
  }
  protected:
  explicit Performance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHorizontalLinearityFieldNumber = 1,
    kVerticalLinearityFieldNumber = 2,
    kResolutionFieldNumber = 3,
    kDynamicRangeFieldNumber = 4,
    kSurplusSensitivityFieldNumber = 5,
  };
  // float horizontalLinearity = 1;
  void clear_horizontallinearity();
  float horizontallinearity() const;
  void set_horizontallinearity(float value);
  private:
  float _internal_horizontallinearity() const;
  void _internal_set_horizontallinearity(float value);
  public:

  // float verticalLinearity = 2;
  void clear_verticallinearity();
  float verticallinearity() const;
  void set_verticallinearity(float value);
  private:
  float _internal_verticallinearity() const;
  void _internal_set_verticallinearity(float value);
  public:

  // float resolution = 3;
  void clear_resolution();
  float resolution() const;
  void set_resolution(float value);
  private:
  float _internal_resolution() const;
  void _internal_set_resolution(float value);
  public:

  // float dynamicRange = 4;
  void clear_dynamicrange();
  float dynamicrange() const;
  void set_dynamicrange(float value);
  private:
  float _internal_dynamicrange() const;
  void _internal_set_dynamicrange(float value);
  public:

  // float surplusSensitivity = 5;
  void clear_surplussensitivity();
  float surplussensitivity() const;
  void set_surplussensitivity(float value);
  private:
  float _internal_surplussensitivity() const;
  void _internal_set_surplussensitivity(float value);
  public:

  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.Performance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float horizontallinearity_;
    float verticallinearity_;
    float resolution_;
    float dynamicrange_;
    float surplussensitivity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// -------------------------------------------------------------------

class Gate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Union.AScan.Proto.Gate) */ {
 public:
  inline Gate() : Gate(nullptr) {}
  ~Gate() override;
  explicit PROTOBUF_CONSTEXPR Gate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Gate(const Gate& from);
  Gate(Gate&& from) noexcept
    : Gate() {
    *this = ::std::move(from);
  }

  inline Gate& operator=(const Gate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gate& operator=(Gate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gate* internal_default_instance() {
    return reinterpret_cast<const Gate*>(
               &_Gate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Gate& a, Gate& b) {
    a.Swap(&b);
  }
  inline void Swap(Gate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Gate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Gate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Gate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Gate& from) {
    Gate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Union.AScan.Proto.Gate";
  }
  protected:
  explicit Gate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdxFieldNumber = 1,
    kPosFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // int32 idx = 1;
  void clear_idx();
  int32_t idx() const;
  void set_idx(int32_t value);
  private:
  int32_t _internal_idx() const;
  void _internal_set_idx(int32_t value);
  public:

  // float pos = 2;
  void clear_pos();
  float pos() const;
  void set_pos(float value);
  private:
  float _internal_pos() const;
  void _internal_set_pos(float value);
  public:

  // float width = 3;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // float height = 4;
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.Gate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t idx_;
    float pos_;
    float width_;
    float height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// -------------------------------------------------------------------

class DACCriteriaBias final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Union.AScan.Proto.DACCriteriaBias) */ {
 public:
  inline DACCriteriaBias() : DACCriteriaBias(nullptr) {}
  ~DACCriteriaBias() override;
  explicit PROTOBUF_CONSTEXPR DACCriteriaBias(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DACCriteriaBias(const DACCriteriaBias& from);
  DACCriteriaBias(DACCriteriaBias&& from) noexcept
    : DACCriteriaBias() {
    *this = ::std::move(from);
  }

  inline DACCriteriaBias& operator=(const DACCriteriaBias& from) {
    CopyFrom(from);
    return *this;
  }
  inline DACCriteriaBias& operator=(DACCriteriaBias&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DACCriteriaBias& default_instance() {
    return *internal_default_instance();
  }
  static inline const DACCriteriaBias* internal_default_instance() {
    return reinterpret_cast<const DACCriteriaBias*>(
               &_DACCriteriaBias_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DACCriteriaBias& a, DACCriteriaBias& b) {
    a.Swap(&b);
  }
  inline void Swap(DACCriteriaBias* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DACCriteriaBias* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DACCriteriaBias* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DACCriteriaBias>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DACCriteriaBias& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DACCriteriaBias& from) {
    DACCriteriaBias::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DACCriteriaBias* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Union.AScan.Proto.DACCriteriaBias";
  }
  protected:
  explicit DACCriteriaBias(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRlBiasFieldNumber = 1,
    kSlBiasFieldNumber = 2,
    kElBiasFieldNumber = 3,
  };
  // sint32 rlBias = 1;
  void clear_rlbias();
  int32_t rlbias() const;
  void set_rlbias(int32_t value);
  private:
  int32_t _internal_rlbias() const;
  void _internal_set_rlbias(int32_t value);
  public:

  // sint32 slBias = 2;
  void clear_slbias();
  int32_t slbias() const;
  void set_slbias(int32_t value);
  private:
  int32_t _internal_slbias() const;
  void _internal_set_slbias(int32_t value);
  public:

  // sint32 elBias = 3;
  void clear_elbias();
  int32_t elbias() const;
  void set_elbias(int32_t value);
  private:
  int32_t _internal_elbias() const;
  void _internal_set_elbias(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.DACCriteriaBias)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t rlbias_;
    int32_t slbias_;
    int32_t elbias_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// -------------------------------------------------------------------

class DAC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Union.AScan.Proto.DAC) */ {
 public:
  inline DAC() : DAC(nullptr) {}
  ~DAC() override;
  explicit PROTOBUF_CONSTEXPR DAC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DAC(const DAC& from);
  DAC(DAC&& from) noexcept
    : DAC() {
    *this = ::std::move(from);
  }

  inline DAC& operator=(const DAC& from) {
    CopyFrom(from);
    return *this;
  }
  inline DAC& operator=(DAC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DAC& default_instance() {
    return *internal_default_instance();
  }
  static inline const DAC* internal_default_instance() {
    return reinterpret_cast<const DAC*>(
               &_DAC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DAC& a, DAC& b) {
    a.Swap(&b);
  }
  inline void Swap(DAC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DAC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DAC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DAC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DAC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DAC& from) {
    DAC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DAC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Union.AScan.Proto.DAC";
  }
  protected:
  explicit DAC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 3,
    kValueFieldNumber = 4,
    kCriteriaBiasFieldNumber = 7,
    kBaseGainFieldNumber = 1,
    kCompensatingGainFieldNumber = 2,
    kEquivalentFieldNumber = 5,
    kCriteriaFieldNumber = 6,
    kIsSubLineFieldNumber = 8,
    kSamplingXAxisBiasFieldNumber = 9,
    kSamplingXAxisLenFieldNumber = 10,
  };
  // repeated float index = 3;
  int index_size() const;
  private:
  int _internal_index_size() const;
  public:
  void clear_index();
  private:
  float _internal_index(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_index() const;
  void _internal_add_index(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_index();
  public:
  float index(int index) const;
  void set_index(int index, float value);
  void add_index(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      index() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_index();

  // repeated float value = 4;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  private:
  float _internal_value(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_value() const;
  void _internal_add_value(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_value();
  public:
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_value();

  // optional .Union.AScan.Proto.DACCriteriaBias criteriaBias = 7;
  bool has_criteriabias() const;
  private:
  bool _internal_has_criteriabias() const;
  public:
  void clear_criteriabias();
  const ::Union::AScan::Proto::DACCriteriaBias& criteriabias() const;
  PROTOBUF_NODISCARD ::Union::AScan::Proto::DACCriteriaBias* release_criteriabias();
  ::Union::AScan::Proto::DACCriteriaBias* mutable_criteriabias();
  void set_allocated_criteriabias(::Union::AScan::Proto::DACCriteriaBias* criteriabias);
  private:
  const ::Union::AScan::Proto::DACCriteriaBias& _internal_criteriabias() const;
  ::Union::AScan::Proto::DACCriteriaBias* _internal_mutable_criteriabias();
  public:
  void unsafe_arena_set_allocated_criteriabias(
      ::Union::AScan::Proto::DACCriteriaBias* criteriabias);
  ::Union::AScan::Proto::DACCriteriaBias* unsafe_arena_release_criteriabias();

  // float baseGain = 1;
  void clear_basegain();
  float basegain() const;
  void set_basegain(float value);
  private:
  float _internal_basegain() const;
  void _internal_set_basegain(float value);
  public:

  // float compensatingGain = 2;
  void clear_compensatinggain();
  float compensatinggain() const;
  void set_compensatinggain(float value);
  private:
  float _internal_compensatinggain() const;
  void _internal_set_compensatinggain(float value);
  public:

  // float equivalent = 5;
  void clear_equivalent();
  float equivalent() const;
  void set_equivalent(float value);
  private:
  float _internal_equivalent() const;
  void _internal_set_equivalent(float value);
  public:

  // .Union.AScan.Proto.DACCriteria criteria = 6;
  void clear_criteria();
  ::Union::AScan::Proto::DACCriteria criteria() const;
  void set_criteria(::Union::AScan::Proto::DACCriteria value);
  private:
  ::Union::AScan::Proto::DACCriteria _internal_criteria() const;
  void _internal_set_criteria(::Union::AScan::Proto::DACCriteria value);
  public:

  // bool isSubLine = 8;
  void clear_issubline();
  bool issubline() const;
  void set_issubline(bool value);
  private:
  bool _internal_issubline() const;
  void _internal_set_issubline(bool value);
  public:

  // float samplingXAxisBias = 9;
  void clear_samplingxaxisbias();
  float samplingxaxisbias() const;
  void set_samplingxaxisbias(float value);
  private:
  float _internal_samplingxaxisbias() const;
  void _internal_set_samplingxaxisbias(float value);
  public:

  // float samplingXAxisLen = 10;
  void clear_samplingxaxislen();
  float samplingxaxislen() const;
  void set_samplingxaxislen(float value);
  private:
  float _internal_samplingxaxislen() const;
  void _internal_set_samplingxaxislen(float value);
  public:

  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.DAC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > index_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > value_;
    ::Union::AScan::Proto::DACCriteriaBias* criteriabias_;
    float basegain_;
    float compensatinggain_;
    float equivalent_;
    int criteria_;
    bool issubline_;
    float samplingxaxisbias_;
    float samplingxaxislen_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// -------------------------------------------------------------------

class AVG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Union.AScan.Proto.AVG) */ {
 public:
  inline AVG() : AVG(nullptr) {}
  ~AVG() override;
  explicit PROTOBUF_CONSTEXPR AVG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AVG(const AVG& from);
  AVG(AVG&& from) noexcept
    : AVG() {
    *this = ::std::move(from);
  }

  inline AVG& operator=(const AVG& from) {
    CopyFrom(from);
    return *this;
  }
  inline AVG& operator=(AVG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AVG& default_instance() {
    return *internal_default_instance();
  }
  static inline const AVG* internal_default_instance() {
    return reinterpret_cast<const AVG*>(
               &_AVG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AVG& a, AVG& b) {
    a.Swap(&b);
  }
  inline void Swap(AVG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AVG* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AVG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AVG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AVG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AVG& from) {
    AVG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AVG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Union.AScan.Proto.AVG";
  }
  protected:
  explicit AVG(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 4,
    kValueFieldNumber = 5,
    kBaseGainFieldNumber = 1,
    kCompensatingGainFieldNumber = 2,
    kScanGainFieldNumber = 3,
    kIsSubLineFieldNumber = 6,
    kSamplingXAxisBiasFieldNumber = 7,
    kSamplingXAxisLenFieldNumber = 8,
    kDiameterFieldNumber = 9,
    kReflectorDiameterFieldNumber = 10,
    kReflectorMaxDepthFieldNumber = 11,
    kEquivalentFieldNumber = 12,
  };
  // repeated float index = 4;
  int index_size() const;
  private:
  int _internal_index_size() const;
  public:
  void clear_index();
  private:
  float _internal_index(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_index() const;
  void _internal_add_index(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_index();
  public:
  float index(int index) const;
  void set_index(int index, float value);
  void add_index(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      index() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_index();

  // repeated float value = 5;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  private:
  float _internal_value(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_value() const;
  void _internal_add_value(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_value();
  public:
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_value();

  // float baseGain = 1;
  void clear_basegain();
  float basegain() const;
  void set_basegain(float value);
  private:
  float _internal_basegain() const;
  void _internal_set_basegain(float value);
  public:

  // float compensatingGain = 2;
  void clear_compensatinggain();
  float compensatinggain() const;
  void set_compensatinggain(float value);
  private:
  float _internal_compensatinggain() const;
  void _internal_set_compensatinggain(float value);
  public:

  // float scanGain = 3;
  void clear_scangain();
  float scangain() const;
  void set_scangain(float value);
  private:
  float _internal_scangain() const;
  void _internal_set_scangain(float value);
  public:

  // bool isSubLine = 6;
  void clear_issubline();
  bool issubline() const;
  void set_issubline(bool value);
  private:
  bool _internal_issubline() const;
  void _internal_set_issubline(bool value);
  public:

  // float samplingXAxisBias = 7;
  void clear_samplingxaxisbias();
  float samplingxaxisbias() const;
  void set_samplingxaxisbias(float value);
  private:
  float _internal_samplingxaxisbias() const;
  void _internal_set_samplingxaxisbias(float value);
  public:

  // float samplingXAxisLen = 8;
  void clear_samplingxaxislen();
  float samplingxaxislen() const;
  void set_samplingxaxislen(float value);
  private:
  float _internal_samplingxaxislen() const;
  void _internal_set_samplingxaxislen(float value);
  public:

  // float diameter = 9;
  void clear_diameter();
  float diameter() const;
  void set_diameter(float value);
  private:
  float _internal_diameter() const;
  void _internal_set_diameter(float value);
  public:

  // float reflectorDiameter = 10;
  void clear_reflectordiameter();
  float reflectordiameter() const;
  void set_reflectordiameter(float value);
  private:
  float _internal_reflectordiameter() const;
  void _internal_set_reflectordiameter(float value);
  public:

  // float reflectorMaxDepth = 11;
  void clear_reflectormaxdepth();
  float reflectormaxdepth() const;
  void set_reflectormaxdepth(float value);
  private:
  float _internal_reflectormaxdepth() const;
  void _internal_set_reflectormaxdepth(float value);
  public:

  // float equivalent = 12;
  void clear_equivalent();
  float equivalent() const;
  void set_equivalent(float value);
  private:
  float _internal_equivalent() const;
  void _internal_set_equivalent(float value);
  public:

  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.AVG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > index_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > value_;
    float basegain_;
    float compensatinggain_;
    float scangain_;
    bool issubline_;
    float samplingxaxisbias_;
    float samplingxaxislen_;
    float diameter_;
    float reflectordiameter_;
    float reflectormaxdepth_;
    float equivalent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// -------------------------------------------------------------------

class InstrumentParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Union.AScan.Proto.InstrumentParameter) */ {
 public:
  inline InstrumentParameter() : InstrumentParameter(nullptr) {}
  ~InstrumentParameter() override;
  explicit PROTOBUF_CONSTEXPR InstrumentParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstrumentParameter(const InstrumentParameter& from);
  InstrumentParameter(InstrumentParameter&& from) noexcept
    : InstrumentParameter() {
    *this = ::std::move(from);
  }

  inline InstrumentParameter& operator=(const InstrumentParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstrumentParameter& operator=(InstrumentParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstrumentParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstrumentParameter* internal_default_instance() {
    return reinterpret_cast<const InstrumentParameter*>(
               &_InstrumentParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InstrumentParameter& a, InstrumentParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(InstrumentParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstrumentParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstrumentParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstrumentParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstrumentParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstrumentParameter& from) {
    InstrumentParameter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Union.AScan.Proto.InstrumentParameter";
  }
  protected:
  explicit InstrumentParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPerformanceFieldNumber = 12,
    kProbeFieldNumber = 3,
    kProbeFrequenceFieldNumber = 4,
    kProbeChipShapeLFieldNumber = 5,
    kProbeChipShapeHFieldNumber = 6,
    kAngleFieldNumber = 7,
    kSoundVelocityFieldNumber = 8,
    kProbeFrontDistanceFieldNumber = 9,
    kZeroPointFieldNumber = 10,
    kChannelFieldNumber = 11,
  };
  // optional .Union.AScan.Proto.Performance performance = 12;
  bool has_performance() const;
  private:
  bool _internal_has_performance() const;
  public:
  void clear_performance();
  const ::Union::AScan::Proto::Performance& performance() const;
  PROTOBUF_NODISCARD ::Union::AScan::Proto::Performance* release_performance();
  ::Union::AScan::Proto::Performance* mutable_performance();
  void set_allocated_performance(::Union::AScan::Proto::Performance* performance);
  private:
  const ::Union::AScan::Proto::Performance& _internal_performance() const;
  ::Union::AScan::Proto::Performance* _internal_mutable_performance();
  public:
  void unsafe_arena_set_allocated_performance(
      ::Union::AScan::Proto::Performance* performance);
  ::Union::AScan::Proto::Performance* unsafe_arena_release_performance();

  // .Union.AScan.Proto.Probe probe = 3;
  void clear_probe();
  ::Union::AScan::Proto::Probe probe() const;
  void set_probe(::Union::AScan::Proto::Probe value);
  private:
  ::Union::AScan::Proto::Probe _internal_probe() const;
  void _internal_set_probe(::Union::AScan::Proto::Probe value);
  public:

  // float probeFrequence = 4;
  void clear_probefrequence();
  float probefrequence() const;
  void set_probefrequence(float value);
  private:
  float _internal_probefrequence() const;
  void _internal_set_probefrequence(float value);
  public:

  // float probeChipShapeL = 5;
  void clear_probechipshapel();
  float probechipshapel() const;
  void set_probechipshapel(float value);
  private:
  float _internal_probechipshapel() const;
  void _internal_set_probechipshapel(float value);
  public:

  // float probeChipShapeH = 6;
  void clear_probechipshapeh();
  float probechipshapeh() const;
  void set_probechipshapeh(float value);
  private:
  float _internal_probechipshapeh() const;
  void _internal_set_probechipshapeh(float value);
  public:

  // float angle = 7;
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // float soundVelocity = 8;
  void clear_soundvelocity();
  float soundvelocity() const;
  void set_soundvelocity(float value);
  private:
  float _internal_soundvelocity() const;
  void _internal_set_soundvelocity(float value);
  public:

  // float probeFrontDistance = 9;
  void clear_probefrontdistance();
  float probefrontdistance() const;
  void set_probefrontdistance(float value);
  private:
  float _internal_probefrontdistance() const;
  void _internal_set_probefrontdistance(float value);
  public:

  // float zeroPoint = 10;
  void clear_zeropoint();
  float zeropoint() const;
  void set_zeropoint(float value);
  private:
  float _internal_zeropoint() const;
  void _internal_set_zeropoint(float value);
  public:

  // int32 channel = 11;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.InstrumentParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Union::AScan::Proto::Performance* performance_;
    int probe_;
    float probefrequence_;
    float probechipshapel_;
    float probechipshapeh_;
    float angle_;
    float soundvelocity_;
    float probefrontdistance_;
    float zeropoint_;
    int32_t channel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// -------------------------------------------------------------------

class ChannelParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Union.AScan.Proto.ChannelParameter) */ {
 public:
  inline ChannelParameter() : ChannelParameter(nullptr) {}
  ~ChannelParameter() override;
  explicit PROTOBUF_CONSTEXPR ChannelParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChannelParameter(const ChannelParameter& from);
  ChannelParameter(ChannelParameter&& from) noexcept
    : ChannelParameter() {
    *this = ::std::move(from);
  }

  inline ChannelParameter& operator=(const ChannelParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelParameter& operator=(ChannelParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelParameter* internal_default_instance() {
    return reinterpret_cast<const ChannelParameter*>(
               &_ChannelParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ChannelParameter& a, ChannelParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChannelParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChannelParameter& from) {
    ChannelParameter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Union.AScan.Proto.ChannelParameter";
  }
  protected:
  explicit ChannelParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGateFieldNumber = 1,
    kAscanFieldNumber = 2,
    kDacFieldNumber = 10,
    kAvgFieldNumber = 11,
    kPerformanceFieldNumber = 12,
    kAxisBiasFieldNumber = 3,
    kAxisLenFieldNumber = 4,
    kBaseGainFieldNumber = 5,
    kScanGainFieldNumber = 6,
    kCompensatingGainFieldNumber = 7,
    kSuppressionFieldNumber = 8,
    kDistanceModeFieldNumber = 9,
  };
  // repeated .Union.AScan.Proto.Gate gate = 1;
  int gate_size() const;
  private:
  int _internal_gate_size() const;
  public:
  void clear_gate();
  ::Union::AScan::Proto::Gate* mutable_gate(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Union::AScan::Proto::Gate >*
      mutable_gate();
  private:
  const ::Union::AScan::Proto::Gate& _internal_gate(int index) const;
  ::Union::AScan::Proto::Gate* _internal_add_gate();
  public:
  const ::Union::AScan::Proto::Gate& gate(int index) const;
  ::Union::AScan::Proto::Gate* add_gate();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Union::AScan::Proto::Gate >&
      gate() const;

  // bytes ascan = 2;
  void clear_ascan();
  const std::string& ascan() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ascan(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ascan();
  PROTOBUF_NODISCARD std::string* release_ascan();
  void set_allocated_ascan(std::string* ascan);
  private:
  const std::string& _internal_ascan() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ascan(const std::string& value);
  std::string* _internal_mutable_ascan();
  public:

  // optional .Union.AScan.Proto.DAC dac = 10;
  bool has_dac() const;
  private:
  bool _internal_has_dac() const;
  public:
  void clear_dac();
  const ::Union::AScan::Proto::DAC& dac() const;
  PROTOBUF_NODISCARD ::Union::AScan::Proto::DAC* release_dac();
  ::Union::AScan::Proto::DAC* mutable_dac();
  void set_allocated_dac(::Union::AScan::Proto::DAC* dac);
  private:
  const ::Union::AScan::Proto::DAC& _internal_dac() const;
  ::Union::AScan::Proto::DAC* _internal_mutable_dac();
  public:
  void unsafe_arena_set_allocated_dac(
      ::Union::AScan::Proto::DAC* dac);
  ::Union::AScan::Proto::DAC* unsafe_arena_release_dac();

  // optional .Union.AScan.Proto.AVG avg = 11;
  bool has_avg() const;
  private:
  bool _internal_has_avg() const;
  public:
  void clear_avg();
  const ::Union::AScan::Proto::AVG& avg() const;
  PROTOBUF_NODISCARD ::Union::AScan::Proto::AVG* release_avg();
  ::Union::AScan::Proto::AVG* mutable_avg();
  void set_allocated_avg(::Union::AScan::Proto::AVG* avg);
  private:
  const ::Union::AScan::Proto::AVG& _internal_avg() const;
  ::Union::AScan::Proto::AVG* _internal_mutable_avg();
  public:
  void unsafe_arena_set_allocated_avg(
      ::Union::AScan::Proto::AVG* avg);
  ::Union::AScan::Proto::AVG* unsafe_arena_release_avg();

  // optional .Union.AScan.Proto.Performance performance = 12;
  bool has_performance() const;
  private:
  bool _internal_has_performance() const;
  public:
  void clear_performance();
  const ::Union::AScan::Proto::Performance& performance() const;
  PROTOBUF_NODISCARD ::Union::AScan::Proto::Performance* release_performance();
  ::Union::AScan::Proto::Performance* mutable_performance();
  void set_allocated_performance(::Union::AScan::Proto::Performance* performance);
  private:
  const ::Union::AScan::Proto::Performance& _internal_performance() const;
  ::Union::AScan::Proto::Performance* _internal_mutable_performance();
  public:
  void unsafe_arena_set_allocated_performance(
      ::Union::AScan::Proto::Performance* performance);
  ::Union::AScan::Proto::Performance* unsafe_arena_release_performance();

  // float axisBias = 3;
  void clear_axisbias();
  float axisbias() const;
  void set_axisbias(float value);
  private:
  float _internal_axisbias() const;
  void _internal_set_axisbias(float value);
  public:

  // float axisLen = 4;
  void clear_axislen();
  float axislen() const;
  void set_axislen(float value);
  private:
  float _internal_axislen() const;
  void _internal_set_axislen(float value);
  public:

  // float baseGain = 5;
  void clear_basegain();
  float basegain() const;
  void set_basegain(float value);
  private:
  float _internal_basegain() const;
  void _internal_set_basegain(float value);
  public:

  // float scanGain = 6;
  void clear_scangain();
  float scangain() const;
  void set_scangain(float value);
  private:
  float _internal_scangain() const;
  void _internal_set_scangain(float value);
  public:

  // float compensatingGain = 7;
  void clear_compensatinggain();
  float compensatinggain() const;
  void set_compensatinggain(float value);
  private:
  float _internal_compensatinggain() const;
  void _internal_set_compensatinggain(float value);
  public:

  // int32 suppression = 8;
  void clear_suppression();
  int32_t suppression() const;
  void set_suppression(int32_t value);
  private:
  int32_t _internal_suppression() const;
  void _internal_set_suppression(int32_t value);
  public:

  // .Union.AScan.Proto.DistanceMode distanceMode = 9;
  void clear_distancemode();
  ::Union::AScan::Proto::DistanceMode distancemode() const;
  void set_distancemode(::Union::AScan::Proto::DistanceMode value);
  private:
  ::Union::AScan::Proto::DistanceMode _internal_distancemode() const;
  void _internal_set_distancemode(::Union::AScan::Proto::DistanceMode value);
  public:

  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.ChannelParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Union::AScan::Proto::Gate > gate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ascan_;
    ::Union::AScan::Proto::DAC* dac_;
    ::Union::AScan::Proto::AVG* avg_;
    ::Union::AScan::Proto::Performance* performance_;
    float axisbias_;
    float axislen_;
    float basegain_;
    float scangain_;
    float compensatinggain_;
    int32_t suppression_;
    int distancemode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// -------------------------------------------------------------------

class AScanPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Union.AScan.Proto.AScanPayload) */ {
 public:
  inline AScanPayload() : AScanPayload(nullptr) {}
  ~AScanPayload() override;
  explicit PROTOBUF_CONSTEXPR AScanPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AScanPayload(const AScanPayload& from);
  AScanPayload(AScanPayload&& from) noexcept
    : AScanPayload() {
    *this = ::std::move(from);
  }

  inline AScanPayload& operator=(const AScanPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline AScanPayload& operator=(AScanPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AScanPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const AScanPayload* internal_default_instance() {
    return reinterpret_cast<const AScanPayload*>(
               &_AScanPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AScanPayload& a, AScanPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(AScanPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AScanPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AScanPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AScanPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AScanPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AScanPayload& from) {
    AScanPayload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AScanPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Union.AScan.Proto.AScanPayload";
  }
  protected:
  explicit AScanPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraDataFieldNumber = 3,
    kInstrumentParameterFieldNumber = 1,
    kChannelParameterFieldNumber = 2,
  };
  // optional bytes cameraData = 3;
  bool has_cameradata() const;
  private:
  bool _internal_has_cameradata() const;
  public:
  void clear_cameradata();
  const std::string& cameradata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cameradata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cameradata();
  PROTOBUF_NODISCARD std::string* release_cameradata();
  void set_allocated_cameradata(std::string* cameradata);
  private:
  const std::string& _internal_cameradata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cameradata(const std::string& value);
  std::string* _internal_mutable_cameradata();
  public:

  // .Union.AScan.Proto.InstrumentParameter instrumentParameter = 1;
  bool has_instrumentparameter() const;
  private:
  bool _internal_has_instrumentparameter() const;
  public:
  void clear_instrumentparameter();
  const ::Union::AScan::Proto::InstrumentParameter& instrumentparameter() const;
  PROTOBUF_NODISCARD ::Union::AScan::Proto::InstrumentParameter* release_instrumentparameter();
  ::Union::AScan::Proto::InstrumentParameter* mutable_instrumentparameter();
  void set_allocated_instrumentparameter(::Union::AScan::Proto::InstrumentParameter* instrumentparameter);
  private:
  const ::Union::AScan::Proto::InstrumentParameter& _internal_instrumentparameter() const;
  ::Union::AScan::Proto::InstrumentParameter* _internal_mutable_instrumentparameter();
  public:
  void unsafe_arena_set_allocated_instrumentparameter(
      ::Union::AScan::Proto::InstrumentParameter* instrumentparameter);
  ::Union::AScan::Proto::InstrumentParameter* unsafe_arena_release_instrumentparameter();

  // .Union.AScan.Proto.ChannelParameter channelParameter = 2;
  bool has_channelparameter() const;
  private:
  bool _internal_has_channelparameter() const;
  public:
  void clear_channelparameter();
  const ::Union::AScan::Proto::ChannelParameter& channelparameter() const;
  PROTOBUF_NODISCARD ::Union::AScan::Proto::ChannelParameter* release_channelparameter();
  ::Union::AScan::Proto::ChannelParameter* mutable_channelparameter();
  void set_allocated_channelparameter(::Union::AScan::Proto::ChannelParameter* channelparameter);
  private:
  const ::Union::AScan::Proto::ChannelParameter& _internal_channelparameter() const;
  ::Union::AScan::Proto::ChannelParameter* _internal_mutable_channelparameter();
  public:
  void unsafe_arena_set_allocated_channelparameter(
      ::Union::AScan::Proto::ChannelParameter* channelparameter);
  ::Union::AScan::Proto::ChannelParameter* unsafe_arena_release_channelparameter();

  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.AScanPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cameradata_;
    ::Union::AScan::Proto::InstrumentParameter* instrumentparameter_;
    ::Union::AScan::Proto::ChannelParameter* channelparameter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// -------------------------------------------------------------------

class AScanHead final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Union.AScan.Proto.AScanHead) */ {
 public:
  inline AScanHead() : AScanHead(nullptr) {}
  ~AScanHead() override;
  explicit PROTOBUF_CONSTEXPR AScanHead(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AScanHead(const AScanHead& from);
  AScanHead(AScanHead&& from) noexcept
    : AScanHead() {
    *this = ::std::move(from);
  }

  inline AScanHead& operator=(const AScanHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline AScanHead& operator=(AScanHead&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AScanHead& default_instance() {
    return *internal_default_instance();
  }
  static inline const AScanHead* internal_default_instance() {
    return reinterpret_cast<const AScanHead*>(
               &_AScanHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AScanHead& a, AScanHead& b) {
    a.Swap(&b);
  }
  inline void Swap(AScanHead* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AScanHead* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AScanHead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AScanHead>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AScanHead& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AScanHead& from) {
    AScanHead::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AScanHead* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Union.AScan.Proto.AScanHead";
  }
  protected:
  explicit AScanHead(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentNameFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // string instrumentName = 1;
  void clear_instrumentname();
  const std::string& instrumentname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instrumentname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instrumentname();
  PROTOBUF_NODISCARD std::string* release_instrumentname();
  void set_allocated_instrumentname(std::string* instrumentname);
  private:
  const std::string& _internal_instrumentname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrumentname(const std::string& value);
  std::string* _internal_mutable_instrumentname();
  public:

  // string time = 2;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.AScanHead)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instrumentname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// -------------------------------------------------------------------

class AScanProtoType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Union.AScan.Proto.AScanProtoType) */ {
 public:
  inline AScanProtoType() : AScanProtoType(nullptr) {}
  ~AScanProtoType() override;
  explicit PROTOBUF_CONSTEXPR AScanProtoType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AScanProtoType(const AScanProtoType& from);
  AScanProtoType(AScanProtoType&& from) noexcept
    : AScanProtoType() {
    *this = ::std::move(from);
  }

  inline AScanProtoType& operator=(const AScanProtoType& from) {
    CopyFrom(from);
    return *this;
  }
  inline AScanProtoType& operator=(AScanProtoType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AScanProtoType& default_instance() {
    return *internal_default_instance();
  }
  static inline const AScanProtoType* internal_default_instance() {
    return reinterpret_cast<const AScanProtoType*>(
               &_AScanProtoType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AScanProtoType& a, AScanProtoType& b) {
    a.Swap(&b);
  }
  inline void Swap(AScanProtoType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AScanProtoType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AScanProtoType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AScanProtoType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AScanProtoType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AScanProtoType& from) {
    AScanProtoType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AScanProtoType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Union.AScan.Proto.AScanProtoType";
  }
  protected:
  explicit AScanProtoType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 2,
    kHeadFieldNumber = 1,
  };
  // repeated .Union.AScan.Proto.AScanPayload payload = 2;
  int payload_size() const;
  private:
  int _internal_payload_size() const;
  public:
  void clear_payload();
  ::Union::AScan::Proto::AScanPayload* mutable_payload(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Union::AScan::Proto::AScanPayload >*
      mutable_payload();
  private:
  const ::Union::AScan::Proto::AScanPayload& _internal_payload(int index) const;
  ::Union::AScan::Proto::AScanPayload* _internal_add_payload();
  public:
  const ::Union::AScan::Proto::AScanPayload& payload(int index) const;
  ::Union::AScan::Proto::AScanPayload* add_payload();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Union::AScan::Proto::AScanPayload >&
      payload() const;

  // .Union.AScan.Proto.AScanHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::Union::AScan::Proto::AScanHead& head() const;
  PROTOBUF_NODISCARD ::Union::AScan::Proto::AScanHead* release_head();
  ::Union::AScan::Proto::AScanHead* mutable_head();
  void set_allocated_head(::Union::AScan::Proto::AScanHead* head);
  private:
  const ::Union::AScan::Proto::AScanHead& _internal_head() const;
  ::Union::AScan::Proto::AScanHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::Union::AScan::Proto::AScanHead* head);
  ::Union::AScan::Proto::AScanHead* unsafe_arena_release_head();

  // @@protoc_insertion_point(class_scope:Union.AScan.Proto.AScanProtoType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Union::AScan::Proto::AScanPayload > payload_;
    ::Union::AScan::Proto::AScanHead* head_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AScan_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Performance

// float horizontalLinearity = 1;
inline void Performance::clear_horizontallinearity() {
  _impl_.horizontallinearity_ = 0;
}
inline float Performance::_internal_horizontallinearity() const {
  return _impl_.horizontallinearity_;
}
inline float Performance::horizontallinearity() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Performance.horizontalLinearity)
  return _internal_horizontallinearity();
}
inline void Performance::_internal_set_horizontallinearity(float value) {
  
  _impl_.horizontallinearity_ = value;
}
inline void Performance::set_horizontallinearity(float value) {
  _internal_set_horizontallinearity(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Performance.horizontalLinearity)
}

// float verticalLinearity = 2;
inline void Performance::clear_verticallinearity() {
  _impl_.verticallinearity_ = 0;
}
inline float Performance::_internal_verticallinearity() const {
  return _impl_.verticallinearity_;
}
inline float Performance::verticallinearity() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Performance.verticalLinearity)
  return _internal_verticallinearity();
}
inline void Performance::_internal_set_verticallinearity(float value) {
  
  _impl_.verticallinearity_ = value;
}
inline void Performance::set_verticallinearity(float value) {
  _internal_set_verticallinearity(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Performance.verticalLinearity)
}

// float resolution = 3;
inline void Performance::clear_resolution() {
  _impl_.resolution_ = 0;
}
inline float Performance::_internal_resolution() const {
  return _impl_.resolution_;
}
inline float Performance::resolution() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Performance.resolution)
  return _internal_resolution();
}
inline void Performance::_internal_set_resolution(float value) {
  
  _impl_.resolution_ = value;
}
inline void Performance::set_resolution(float value) {
  _internal_set_resolution(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Performance.resolution)
}

// float dynamicRange = 4;
inline void Performance::clear_dynamicrange() {
  _impl_.dynamicrange_ = 0;
}
inline float Performance::_internal_dynamicrange() const {
  return _impl_.dynamicrange_;
}
inline float Performance::dynamicrange() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Performance.dynamicRange)
  return _internal_dynamicrange();
}
inline void Performance::_internal_set_dynamicrange(float value) {
  
  _impl_.dynamicrange_ = value;
}
inline void Performance::set_dynamicrange(float value) {
  _internal_set_dynamicrange(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Performance.dynamicRange)
}

// float surplusSensitivity = 5;
inline void Performance::clear_surplussensitivity() {
  _impl_.surplussensitivity_ = 0;
}
inline float Performance::_internal_surplussensitivity() const {
  return _impl_.surplussensitivity_;
}
inline float Performance::surplussensitivity() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Performance.surplusSensitivity)
  return _internal_surplussensitivity();
}
inline void Performance::_internal_set_surplussensitivity(float value) {
  
  _impl_.surplussensitivity_ = value;
}
inline void Performance::set_surplussensitivity(float value) {
  _internal_set_surplussensitivity(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Performance.surplusSensitivity)
}

// -------------------------------------------------------------------

// Gate

// int32 idx = 1;
inline void Gate::clear_idx() {
  _impl_.idx_ = 0;
}
inline int32_t Gate::_internal_idx() const {
  return _impl_.idx_;
}
inline int32_t Gate::idx() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Gate.idx)
  return _internal_idx();
}
inline void Gate::_internal_set_idx(int32_t value) {
  
  _impl_.idx_ = value;
}
inline void Gate::set_idx(int32_t value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Gate.idx)
}

// float pos = 2;
inline void Gate::clear_pos() {
  _impl_.pos_ = 0;
}
inline float Gate::_internal_pos() const {
  return _impl_.pos_;
}
inline float Gate::pos() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Gate.pos)
  return _internal_pos();
}
inline void Gate::_internal_set_pos(float value) {
  
  _impl_.pos_ = value;
}
inline void Gate::set_pos(float value) {
  _internal_set_pos(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Gate.pos)
}

// float width = 3;
inline void Gate::clear_width() {
  _impl_.width_ = 0;
}
inline float Gate::_internal_width() const {
  return _impl_.width_;
}
inline float Gate::width() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Gate.width)
  return _internal_width();
}
inline void Gate::_internal_set_width(float value) {
  
  _impl_.width_ = value;
}
inline void Gate::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Gate.width)
}

// float height = 4;
inline void Gate::clear_height() {
  _impl_.height_ = 0;
}
inline float Gate::_internal_height() const {
  return _impl_.height_;
}
inline float Gate::height() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.Gate.height)
  return _internal_height();
}
inline void Gate::_internal_set_height(float value) {
  
  _impl_.height_ = value;
}
inline void Gate::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.Gate.height)
}

// -------------------------------------------------------------------

// DACCriteriaBias

// sint32 rlBias = 1;
inline void DACCriteriaBias::clear_rlbias() {
  _impl_.rlbias_ = 0;
}
inline int32_t DACCriteriaBias::_internal_rlbias() const {
  return _impl_.rlbias_;
}
inline int32_t DACCriteriaBias::rlbias() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DACCriteriaBias.rlBias)
  return _internal_rlbias();
}
inline void DACCriteriaBias::_internal_set_rlbias(int32_t value) {
  
  _impl_.rlbias_ = value;
}
inline void DACCriteriaBias::set_rlbias(int32_t value) {
  _internal_set_rlbias(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DACCriteriaBias.rlBias)
}

// sint32 slBias = 2;
inline void DACCriteriaBias::clear_slbias() {
  _impl_.slbias_ = 0;
}
inline int32_t DACCriteriaBias::_internal_slbias() const {
  return _impl_.slbias_;
}
inline int32_t DACCriteriaBias::slbias() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DACCriteriaBias.slBias)
  return _internal_slbias();
}
inline void DACCriteriaBias::_internal_set_slbias(int32_t value) {
  
  _impl_.slbias_ = value;
}
inline void DACCriteriaBias::set_slbias(int32_t value) {
  _internal_set_slbias(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DACCriteriaBias.slBias)
}

// sint32 elBias = 3;
inline void DACCriteriaBias::clear_elbias() {
  _impl_.elbias_ = 0;
}
inline int32_t DACCriteriaBias::_internal_elbias() const {
  return _impl_.elbias_;
}
inline int32_t DACCriteriaBias::elbias() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DACCriteriaBias.elBias)
  return _internal_elbias();
}
inline void DACCriteriaBias::_internal_set_elbias(int32_t value) {
  
  _impl_.elbias_ = value;
}
inline void DACCriteriaBias::set_elbias(int32_t value) {
  _internal_set_elbias(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DACCriteriaBias.elBias)
}

// -------------------------------------------------------------------

// DAC

// float baseGain = 1;
inline void DAC::clear_basegain() {
  _impl_.basegain_ = 0;
}
inline float DAC::_internal_basegain() const {
  return _impl_.basegain_;
}
inline float DAC::basegain() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.baseGain)
  return _internal_basegain();
}
inline void DAC::_internal_set_basegain(float value) {
  
  _impl_.basegain_ = value;
}
inline void DAC::set_basegain(float value) {
  _internal_set_basegain(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.baseGain)
}

// float compensatingGain = 2;
inline void DAC::clear_compensatinggain() {
  _impl_.compensatinggain_ = 0;
}
inline float DAC::_internal_compensatinggain() const {
  return _impl_.compensatinggain_;
}
inline float DAC::compensatinggain() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.compensatingGain)
  return _internal_compensatinggain();
}
inline void DAC::_internal_set_compensatinggain(float value) {
  
  _impl_.compensatinggain_ = value;
}
inline void DAC::set_compensatinggain(float value) {
  _internal_set_compensatinggain(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.compensatingGain)
}

// repeated float index = 3;
inline int DAC::_internal_index_size() const {
  return _impl_.index_.size();
}
inline int DAC::index_size() const {
  return _internal_index_size();
}
inline void DAC::clear_index() {
  _impl_.index_.Clear();
}
inline float DAC::_internal_index(int index) const {
  return _impl_.index_.Get(index);
}
inline float DAC::index(int index) const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.index)
  return _internal_index(index);
}
inline void DAC::set_index(int index, float value) {
  _impl_.index_.Set(index, value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.index)
}
inline void DAC::_internal_add_index(float value) {
  _impl_.index_.Add(value);
}
inline void DAC::add_index(float value) {
  _internal_add_index(value);
  // @@protoc_insertion_point(field_add:Union.AScan.Proto.DAC.index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
DAC::_internal_index() const {
  return _impl_.index_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
DAC::index() const {
  // @@protoc_insertion_point(field_list:Union.AScan.Proto.DAC.index)
  return _internal_index();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
DAC::_internal_mutable_index() {
  return &_impl_.index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
DAC::mutable_index() {
  // @@protoc_insertion_point(field_mutable_list:Union.AScan.Proto.DAC.index)
  return _internal_mutable_index();
}

// repeated float value = 4;
inline int DAC::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int DAC::value_size() const {
  return _internal_value_size();
}
inline void DAC::clear_value() {
  _impl_.value_.Clear();
}
inline float DAC::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline float DAC::value(int index) const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.value)
  return _internal_value(index);
}
inline void DAC::set_value(int index, float value) {
  _impl_.value_.Set(index, value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.value)
}
inline void DAC::_internal_add_value(float value) {
  _impl_.value_.Add(value);
}
inline void DAC::add_value(float value) {
  _internal_add_value(value);
  // @@protoc_insertion_point(field_add:Union.AScan.Proto.DAC.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
DAC::_internal_value() const {
  return _impl_.value_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
DAC::value() const {
  // @@protoc_insertion_point(field_list:Union.AScan.Proto.DAC.value)
  return _internal_value();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
DAC::_internal_mutable_value() {
  return &_impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
DAC::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:Union.AScan.Proto.DAC.value)
  return _internal_mutable_value();
}

// float equivalent = 5;
inline void DAC::clear_equivalent() {
  _impl_.equivalent_ = 0;
}
inline float DAC::_internal_equivalent() const {
  return _impl_.equivalent_;
}
inline float DAC::equivalent() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.equivalent)
  return _internal_equivalent();
}
inline void DAC::_internal_set_equivalent(float value) {
  
  _impl_.equivalent_ = value;
}
inline void DAC::set_equivalent(float value) {
  _internal_set_equivalent(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.equivalent)
}

// .Union.AScan.Proto.DACCriteria criteria = 6;
inline void DAC::clear_criteria() {
  _impl_.criteria_ = 0;
}
inline ::Union::AScan::Proto::DACCriteria DAC::_internal_criteria() const {
  return static_cast< ::Union::AScan::Proto::DACCriteria >(_impl_.criteria_);
}
inline ::Union::AScan::Proto::DACCriteria DAC::criteria() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.criteria)
  return _internal_criteria();
}
inline void DAC::_internal_set_criteria(::Union::AScan::Proto::DACCriteria value) {
  
  _impl_.criteria_ = value;
}
inline void DAC::set_criteria(::Union::AScan::Proto::DACCriteria value) {
  _internal_set_criteria(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.criteria)
}

// optional .Union.AScan.Proto.DACCriteriaBias criteriaBias = 7;
inline bool DAC::_internal_has_criteriabias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.criteriabias_ != nullptr);
  return value;
}
inline bool DAC::has_criteriabias() const {
  return _internal_has_criteriabias();
}
inline void DAC::clear_criteriabias() {
  if (_impl_.criteriabias_ != nullptr) _impl_.criteriabias_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Union::AScan::Proto::DACCriteriaBias& DAC::_internal_criteriabias() const {
  const ::Union::AScan::Proto::DACCriteriaBias* p = _impl_.criteriabias_;
  return p != nullptr ? *p : reinterpret_cast<const ::Union::AScan::Proto::DACCriteriaBias&>(
      ::Union::AScan::Proto::_DACCriteriaBias_default_instance_);
}
inline const ::Union::AScan::Proto::DACCriteriaBias& DAC::criteriabias() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.criteriaBias)
  return _internal_criteriabias();
}
inline void DAC::unsafe_arena_set_allocated_criteriabias(
    ::Union::AScan::Proto::DACCriteriaBias* criteriabias) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.criteriabias_);
  }
  _impl_.criteriabias_ = criteriabias;
  if (criteriabias) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Union.AScan.Proto.DAC.criteriaBias)
}
inline ::Union::AScan::Proto::DACCriteriaBias* DAC::release_criteriabias() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Union::AScan::Proto::DACCriteriaBias* temp = _impl_.criteriabias_;
  _impl_.criteriabias_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Union::AScan::Proto::DACCriteriaBias* DAC::unsafe_arena_release_criteriabias() {
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.DAC.criteriaBias)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Union::AScan::Proto::DACCriteriaBias* temp = _impl_.criteriabias_;
  _impl_.criteriabias_ = nullptr;
  return temp;
}
inline ::Union::AScan::Proto::DACCriteriaBias* DAC::_internal_mutable_criteriabias() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.criteriabias_ == nullptr) {
    auto* p = CreateMaybeMessage<::Union::AScan::Proto::DACCriteriaBias>(GetArenaForAllocation());
    _impl_.criteriabias_ = p;
  }
  return _impl_.criteriabias_;
}
inline ::Union::AScan::Proto::DACCriteriaBias* DAC::mutable_criteriabias() {
  ::Union::AScan::Proto::DACCriteriaBias* _msg = _internal_mutable_criteriabias();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.DAC.criteriaBias)
  return _msg;
}
inline void DAC::set_allocated_criteriabias(::Union::AScan::Proto::DACCriteriaBias* criteriabias) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.criteriabias_;
  }
  if (criteriabias) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(criteriabias);
    if (message_arena != submessage_arena) {
      criteriabias = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, criteriabias, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.criteriabias_ = criteriabias;
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.DAC.criteriaBias)
}

// bool isSubLine = 8;
inline void DAC::clear_issubline() {
  _impl_.issubline_ = false;
}
inline bool DAC::_internal_issubline() const {
  return _impl_.issubline_;
}
inline bool DAC::issubline() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.isSubLine)
  return _internal_issubline();
}
inline void DAC::_internal_set_issubline(bool value) {
  
  _impl_.issubline_ = value;
}
inline void DAC::set_issubline(bool value) {
  _internal_set_issubline(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.isSubLine)
}

// float samplingXAxisBias = 9;
inline void DAC::clear_samplingxaxisbias() {
  _impl_.samplingxaxisbias_ = 0;
}
inline float DAC::_internal_samplingxaxisbias() const {
  return _impl_.samplingxaxisbias_;
}
inline float DAC::samplingxaxisbias() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.samplingXAxisBias)
  return _internal_samplingxaxisbias();
}
inline void DAC::_internal_set_samplingxaxisbias(float value) {
  
  _impl_.samplingxaxisbias_ = value;
}
inline void DAC::set_samplingxaxisbias(float value) {
  _internal_set_samplingxaxisbias(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.samplingXAxisBias)
}

// float samplingXAxisLen = 10;
inline void DAC::clear_samplingxaxislen() {
  _impl_.samplingxaxislen_ = 0;
}
inline float DAC::_internal_samplingxaxislen() const {
  return _impl_.samplingxaxislen_;
}
inline float DAC::samplingxaxislen() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.DAC.samplingXAxisLen)
  return _internal_samplingxaxislen();
}
inline void DAC::_internal_set_samplingxaxislen(float value) {
  
  _impl_.samplingxaxislen_ = value;
}
inline void DAC::set_samplingxaxislen(float value) {
  _internal_set_samplingxaxislen(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.DAC.samplingXAxisLen)
}

// -------------------------------------------------------------------

// AVG

// float baseGain = 1;
inline void AVG::clear_basegain() {
  _impl_.basegain_ = 0;
}
inline float AVG::_internal_basegain() const {
  return _impl_.basegain_;
}
inline float AVG::basegain() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.baseGain)
  return _internal_basegain();
}
inline void AVG::_internal_set_basegain(float value) {
  
  _impl_.basegain_ = value;
}
inline void AVG::set_basegain(float value) {
  _internal_set_basegain(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.baseGain)
}

// float compensatingGain = 2;
inline void AVG::clear_compensatinggain() {
  _impl_.compensatinggain_ = 0;
}
inline float AVG::_internal_compensatinggain() const {
  return _impl_.compensatinggain_;
}
inline float AVG::compensatinggain() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.compensatingGain)
  return _internal_compensatinggain();
}
inline void AVG::_internal_set_compensatinggain(float value) {
  
  _impl_.compensatinggain_ = value;
}
inline void AVG::set_compensatinggain(float value) {
  _internal_set_compensatinggain(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.compensatingGain)
}

// float scanGain = 3;
inline void AVG::clear_scangain() {
  _impl_.scangain_ = 0;
}
inline float AVG::_internal_scangain() const {
  return _impl_.scangain_;
}
inline float AVG::scangain() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.scanGain)
  return _internal_scangain();
}
inline void AVG::_internal_set_scangain(float value) {
  
  _impl_.scangain_ = value;
}
inline void AVG::set_scangain(float value) {
  _internal_set_scangain(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.scanGain)
}

// repeated float index = 4;
inline int AVG::_internal_index_size() const {
  return _impl_.index_.size();
}
inline int AVG::index_size() const {
  return _internal_index_size();
}
inline void AVG::clear_index() {
  _impl_.index_.Clear();
}
inline float AVG::_internal_index(int index) const {
  return _impl_.index_.Get(index);
}
inline float AVG::index(int index) const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.index)
  return _internal_index(index);
}
inline void AVG::set_index(int index, float value) {
  _impl_.index_.Set(index, value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.index)
}
inline void AVG::_internal_add_index(float value) {
  _impl_.index_.Add(value);
}
inline void AVG::add_index(float value) {
  _internal_add_index(value);
  // @@protoc_insertion_point(field_add:Union.AScan.Proto.AVG.index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
AVG::_internal_index() const {
  return _impl_.index_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
AVG::index() const {
  // @@protoc_insertion_point(field_list:Union.AScan.Proto.AVG.index)
  return _internal_index();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
AVG::_internal_mutable_index() {
  return &_impl_.index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
AVG::mutable_index() {
  // @@protoc_insertion_point(field_mutable_list:Union.AScan.Proto.AVG.index)
  return _internal_mutable_index();
}

// repeated float value = 5;
inline int AVG::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int AVG::value_size() const {
  return _internal_value_size();
}
inline void AVG::clear_value() {
  _impl_.value_.Clear();
}
inline float AVG::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline float AVG::value(int index) const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.value)
  return _internal_value(index);
}
inline void AVG::set_value(int index, float value) {
  _impl_.value_.Set(index, value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.value)
}
inline void AVG::_internal_add_value(float value) {
  _impl_.value_.Add(value);
}
inline void AVG::add_value(float value) {
  _internal_add_value(value);
  // @@protoc_insertion_point(field_add:Union.AScan.Proto.AVG.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
AVG::_internal_value() const {
  return _impl_.value_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
AVG::value() const {
  // @@protoc_insertion_point(field_list:Union.AScan.Proto.AVG.value)
  return _internal_value();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
AVG::_internal_mutable_value() {
  return &_impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
AVG::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:Union.AScan.Proto.AVG.value)
  return _internal_mutable_value();
}

// bool isSubLine = 6;
inline void AVG::clear_issubline() {
  _impl_.issubline_ = false;
}
inline bool AVG::_internal_issubline() const {
  return _impl_.issubline_;
}
inline bool AVG::issubline() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.isSubLine)
  return _internal_issubline();
}
inline void AVG::_internal_set_issubline(bool value) {
  
  _impl_.issubline_ = value;
}
inline void AVG::set_issubline(bool value) {
  _internal_set_issubline(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.isSubLine)
}

// float samplingXAxisBias = 7;
inline void AVG::clear_samplingxaxisbias() {
  _impl_.samplingxaxisbias_ = 0;
}
inline float AVG::_internal_samplingxaxisbias() const {
  return _impl_.samplingxaxisbias_;
}
inline float AVG::samplingxaxisbias() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.samplingXAxisBias)
  return _internal_samplingxaxisbias();
}
inline void AVG::_internal_set_samplingxaxisbias(float value) {
  
  _impl_.samplingxaxisbias_ = value;
}
inline void AVG::set_samplingxaxisbias(float value) {
  _internal_set_samplingxaxisbias(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.samplingXAxisBias)
}

// float samplingXAxisLen = 8;
inline void AVG::clear_samplingxaxislen() {
  _impl_.samplingxaxislen_ = 0;
}
inline float AVG::_internal_samplingxaxislen() const {
  return _impl_.samplingxaxislen_;
}
inline float AVG::samplingxaxislen() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.samplingXAxisLen)
  return _internal_samplingxaxislen();
}
inline void AVG::_internal_set_samplingxaxislen(float value) {
  
  _impl_.samplingxaxislen_ = value;
}
inline void AVG::set_samplingxaxislen(float value) {
  _internal_set_samplingxaxislen(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.samplingXAxisLen)
}

// float diameter = 9;
inline void AVG::clear_diameter() {
  _impl_.diameter_ = 0;
}
inline float AVG::_internal_diameter() const {
  return _impl_.diameter_;
}
inline float AVG::diameter() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.diameter)
  return _internal_diameter();
}
inline void AVG::_internal_set_diameter(float value) {
  
  _impl_.diameter_ = value;
}
inline void AVG::set_diameter(float value) {
  _internal_set_diameter(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.diameter)
}

// float reflectorDiameter = 10;
inline void AVG::clear_reflectordiameter() {
  _impl_.reflectordiameter_ = 0;
}
inline float AVG::_internal_reflectordiameter() const {
  return _impl_.reflectordiameter_;
}
inline float AVG::reflectordiameter() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.reflectorDiameter)
  return _internal_reflectordiameter();
}
inline void AVG::_internal_set_reflectordiameter(float value) {
  
  _impl_.reflectordiameter_ = value;
}
inline void AVG::set_reflectordiameter(float value) {
  _internal_set_reflectordiameter(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.reflectorDiameter)
}

// float reflectorMaxDepth = 11;
inline void AVG::clear_reflectormaxdepth() {
  _impl_.reflectormaxdepth_ = 0;
}
inline float AVG::_internal_reflectormaxdepth() const {
  return _impl_.reflectormaxdepth_;
}
inline float AVG::reflectormaxdepth() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.reflectorMaxDepth)
  return _internal_reflectormaxdepth();
}
inline void AVG::_internal_set_reflectormaxdepth(float value) {
  
  _impl_.reflectormaxdepth_ = value;
}
inline void AVG::set_reflectormaxdepth(float value) {
  _internal_set_reflectormaxdepth(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.reflectorMaxDepth)
}

// float equivalent = 12;
inline void AVG::clear_equivalent() {
  _impl_.equivalent_ = 0;
}
inline float AVG::_internal_equivalent() const {
  return _impl_.equivalent_;
}
inline float AVG::equivalent() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AVG.equivalent)
  return _internal_equivalent();
}
inline void AVG::_internal_set_equivalent(float value) {
  
  _impl_.equivalent_ = value;
}
inline void AVG::set_equivalent(float value) {
  _internal_set_equivalent(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AVG.equivalent)
}

// -------------------------------------------------------------------

// InstrumentParameter

// .Union.AScan.Proto.Probe probe = 3;
inline void InstrumentParameter::clear_probe() {
  _impl_.probe_ = 0;
}
inline ::Union::AScan::Proto::Probe InstrumentParameter::_internal_probe() const {
  return static_cast< ::Union::AScan::Proto::Probe >(_impl_.probe_);
}
inline ::Union::AScan::Proto::Probe InstrumentParameter::probe() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.probe)
  return _internal_probe();
}
inline void InstrumentParameter::_internal_set_probe(::Union::AScan::Proto::Probe value) {
  
  _impl_.probe_ = value;
}
inline void InstrumentParameter::set_probe(::Union::AScan::Proto::Probe value) {
  _internal_set_probe(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.probe)
}

// float probeFrequence = 4;
inline void InstrumentParameter::clear_probefrequence() {
  _impl_.probefrequence_ = 0;
}
inline float InstrumentParameter::_internal_probefrequence() const {
  return _impl_.probefrequence_;
}
inline float InstrumentParameter::probefrequence() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.probeFrequence)
  return _internal_probefrequence();
}
inline void InstrumentParameter::_internal_set_probefrequence(float value) {
  
  _impl_.probefrequence_ = value;
}
inline void InstrumentParameter::set_probefrequence(float value) {
  _internal_set_probefrequence(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.probeFrequence)
}

// float probeChipShapeL = 5;
inline void InstrumentParameter::clear_probechipshapel() {
  _impl_.probechipshapel_ = 0;
}
inline float InstrumentParameter::_internal_probechipshapel() const {
  return _impl_.probechipshapel_;
}
inline float InstrumentParameter::probechipshapel() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.probeChipShapeL)
  return _internal_probechipshapel();
}
inline void InstrumentParameter::_internal_set_probechipshapel(float value) {
  
  _impl_.probechipshapel_ = value;
}
inline void InstrumentParameter::set_probechipshapel(float value) {
  _internal_set_probechipshapel(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.probeChipShapeL)
}

// float probeChipShapeH = 6;
inline void InstrumentParameter::clear_probechipshapeh() {
  _impl_.probechipshapeh_ = 0;
}
inline float InstrumentParameter::_internal_probechipshapeh() const {
  return _impl_.probechipshapeh_;
}
inline float InstrumentParameter::probechipshapeh() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.probeChipShapeH)
  return _internal_probechipshapeh();
}
inline void InstrumentParameter::_internal_set_probechipshapeh(float value) {
  
  _impl_.probechipshapeh_ = value;
}
inline void InstrumentParameter::set_probechipshapeh(float value) {
  _internal_set_probechipshapeh(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.probeChipShapeH)
}

// float angle = 7;
inline void InstrumentParameter::clear_angle() {
  _impl_.angle_ = 0;
}
inline float InstrumentParameter::_internal_angle() const {
  return _impl_.angle_;
}
inline float InstrumentParameter::angle() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.angle)
  return _internal_angle();
}
inline void InstrumentParameter::_internal_set_angle(float value) {
  
  _impl_.angle_ = value;
}
inline void InstrumentParameter::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.angle)
}

// float soundVelocity = 8;
inline void InstrumentParameter::clear_soundvelocity() {
  _impl_.soundvelocity_ = 0;
}
inline float InstrumentParameter::_internal_soundvelocity() const {
  return _impl_.soundvelocity_;
}
inline float InstrumentParameter::soundvelocity() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.soundVelocity)
  return _internal_soundvelocity();
}
inline void InstrumentParameter::_internal_set_soundvelocity(float value) {
  
  _impl_.soundvelocity_ = value;
}
inline void InstrumentParameter::set_soundvelocity(float value) {
  _internal_set_soundvelocity(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.soundVelocity)
}

// float probeFrontDistance = 9;
inline void InstrumentParameter::clear_probefrontdistance() {
  _impl_.probefrontdistance_ = 0;
}
inline float InstrumentParameter::_internal_probefrontdistance() const {
  return _impl_.probefrontdistance_;
}
inline float InstrumentParameter::probefrontdistance() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.probeFrontDistance)
  return _internal_probefrontdistance();
}
inline void InstrumentParameter::_internal_set_probefrontdistance(float value) {
  
  _impl_.probefrontdistance_ = value;
}
inline void InstrumentParameter::set_probefrontdistance(float value) {
  _internal_set_probefrontdistance(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.probeFrontDistance)
}

// float zeroPoint = 10;
inline void InstrumentParameter::clear_zeropoint() {
  _impl_.zeropoint_ = 0;
}
inline float InstrumentParameter::_internal_zeropoint() const {
  return _impl_.zeropoint_;
}
inline float InstrumentParameter::zeropoint() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.zeroPoint)
  return _internal_zeropoint();
}
inline void InstrumentParameter::_internal_set_zeropoint(float value) {
  
  _impl_.zeropoint_ = value;
}
inline void InstrumentParameter::set_zeropoint(float value) {
  _internal_set_zeropoint(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.zeroPoint)
}

// int32 channel = 11;
inline void InstrumentParameter::clear_channel() {
  _impl_.channel_ = 0;
}
inline int32_t InstrumentParameter::_internal_channel() const {
  return _impl_.channel_;
}
inline int32_t InstrumentParameter::channel() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.channel)
  return _internal_channel();
}
inline void InstrumentParameter::_internal_set_channel(int32_t value) {
  
  _impl_.channel_ = value;
}
inline void InstrumentParameter::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.InstrumentParameter.channel)
}

// optional .Union.AScan.Proto.Performance performance = 12;
inline bool InstrumentParameter::_internal_has_performance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.performance_ != nullptr);
  return value;
}
inline bool InstrumentParameter::has_performance() const {
  return _internal_has_performance();
}
inline void InstrumentParameter::clear_performance() {
  if (_impl_.performance_ != nullptr) _impl_.performance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Union::AScan::Proto::Performance& InstrumentParameter::_internal_performance() const {
  const ::Union::AScan::Proto::Performance* p = _impl_.performance_;
  return p != nullptr ? *p : reinterpret_cast<const ::Union::AScan::Proto::Performance&>(
      ::Union::AScan::Proto::_Performance_default_instance_);
}
inline const ::Union::AScan::Proto::Performance& InstrumentParameter::performance() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.InstrumentParameter.performance)
  return _internal_performance();
}
inline void InstrumentParameter::unsafe_arena_set_allocated_performance(
    ::Union::AScan::Proto::Performance* performance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.performance_);
  }
  _impl_.performance_ = performance;
  if (performance) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Union.AScan.Proto.InstrumentParameter.performance)
}
inline ::Union::AScan::Proto::Performance* InstrumentParameter::release_performance() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Union::AScan::Proto::Performance* temp = _impl_.performance_;
  _impl_.performance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Union::AScan::Proto::Performance* InstrumentParameter::unsafe_arena_release_performance() {
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.InstrumentParameter.performance)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Union::AScan::Proto::Performance* temp = _impl_.performance_;
  _impl_.performance_ = nullptr;
  return temp;
}
inline ::Union::AScan::Proto::Performance* InstrumentParameter::_internal_mutable_performance() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.performance_ == nullptr) {
    auto* p = CreateMaybeMessage<::Union::AScan::Proto::Performance>(GetArenaForAllocation());
    _impl_.performance_ = p;
  }
  return _impl_.performance_;
}
inline ::Union::AScan::Proto::Performance* InstrumentParameter::mutable_performance() {
  ::Union::AScan::Proto::Performance* _msg = _internal_mutable_performance();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.InstrumentParameter.performance)
  return _msg;
}
inline void InstrumentParameter::set_allocated_performance(::Union::AScan::Proto::Performance* performance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.performance_;
  }
  if (performance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(performance);
    if (message_arena != submessage_arena) {
      performance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, performance, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.performance_ = performance;
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.InstrumentParameter.performance)
}

// -------------------------------------------------------------------

// ChannelParameter

// repeated .Union.AScan.Proto.Gate gate = 1;
inline int ChannelParameter::_internal_gate_size() const {
  return _impl_.gate_.size();
}
inline int ChannelParameter::gate_size() const {
  return _internal_gate_size();
}
inline void ChannelParameter::clear_gate() {
  _impl_.gate_.Clear();
}
inline ::Union::AScan::Proto::Gate* ChannelParameter::mutable_gate(int index) {
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.ChannelParameter.gate)
  return _impl_.gate_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Union::AScan::Proto::Gate >*
ChannelParameter::mutable_gate() {
  // @@protoc_insertion_point(field_mutable_list:Union.AScan.Proto.ChannelParameter.gate)
  return &_impl_.gate_;
}
inline const ::Union::AScan::Proto::Gate& ChannelParameter::_internal_gate(int index) const {
  return _impl_.gate_.Get(index);
}
inline const ::Union::AScan::Proto::Gate& ChannelParameter::gate(int index) const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.gate)
  return _internal_gate(index);
}
inline ::Union::AScan::Proto::Gate* ChannelParameter::_internal_add_gate() {
  return _impl_.gate_.Add();
}
inline ::Union::AScan::Proto::Gate* ChannelParameter::add_gate() {
  ::Union::AScan::Proto::Gate* _add = _internal_add_gate();
  // @@protoc_insertion_point(field_add:Union.AScan.Proto.ChannelParameter.gate)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Union::AScan::Proto::Gate >&
ChannelParameter::gate() const {
  // @@protoc_insertion_point(field_list:Union.AScan.Proto.ChannelParameter.gate)
  return _impl_.gate_;
}

// bytes ascan = 2;
inline void ChannelParameter::clear_ascan() {
  _impl_.ascan_.ClearToEmpty();
}
inline const std::string& ChannelParameter::ascan() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.ascan)
  return _internal_ascan();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChannelParameter::set_ascan(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ascan_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.ChannelParameter.ascan)
}
inline std::string* ChannelParameter::mutable_ascan() {
  std::string* _s = _internal_mutable_ascan();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.ChannelParameter.ascan)
  return _s;
}
inline const std::string& ChannelParameter::_internal_ascan() const {
  return _impl_.ascan_.Get();
}
inline void ChannelParameter::_internal_set_ascan(const std::string& value) {
  
  _impl_.ascan_.Set(value, GetArenaForAllocation());
}
inline std::string* ChannelParameter::_internal_mutable_ascan() {
  
  return _impl_.ascan_.Mutable(GetArenaForAllocation());
}
inline std::string* ChannelParameter::release_ascan() {
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.ChannelParameter.ascan)
  return _impl_.ascan_.Release();
}
inline void ChannelParameter::set_allocated_ascan(std::string* ascan) {
  if (ascan != nullptr) {
    
  } else {
    
  }
  _impl_.ascan_.SetAllocated(ascan, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ascan_.IsDefault()) {
    _impl_.ascan_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.ChannelParameter.ascan)
}

// float axisBias = 3;
inline void ChannelParameter::clear_axisbias() {
  _impl_.axisbias_ = 0;
}
inline float ChannelParameter::_internal_axisbias() const {
  return _impl_.axisbias_;
}
inline float ChannelParameter::axisbias() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.axisBias)
  return _internal_axisbias();
}
inline void ChannelParameter::_internal_set_axisbias(float value) {
  
  _impl_.axisbias_ = value;
}
inline void ChannelParameter::set_axisbias(float value) {
  _internal_set_axisbias(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.ChannelParameter.axisBias)
}

// float axisLen = 4;
inline void ChannelParameter::clear_axislen() {
  _impl_.axislen_ = 0;
}
inline float ChannelParameter::_internal_axislen() const {
  return _impl_.axislen_;
}
inline float ChannelParameter::axislen() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.axisLen)
  return _internal_axislen();
}
inline void ChannelParameter::_internal_set_axislen(float value) {
  
  _impl_.axislen_ = value;
}
inline void ChannelParameter::set_axislen(float value) {
  _internal_set_axislen(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.ChannelParameter.axisLen)
}

// float baseGain = 5;
inline void ChannelParameter::clear_basegain() {
  _impl_.basegain_ = 0;
}
inline float ChannelParameter::_internal_basegain() const {
  return _impl_.basegain_;
}
inline float ChannelParameter::basegain() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.baseGain)
  return _internal_basegain();
}
inline void ChannelParameter::_internal_set_basegain(float value) {
  
  _impl_.basegain_ = value;
}
inline void ChannelParameter::set_basegain(float value) {
  _internal_set_basegain(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.ChannelParameter.baseGain)
}

// float scanGain = 6;
inline void ChannelParameter::clear_scangain() {
  _impl_.scangain_ = 0;
}
inline float ChannelParameter::_internal_scangain() const {
  return _impl_.scangain_;
}
inline float ChannelParameter::scangain() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.scanGain)
  return _internal_scangain();
}
inline void ChannelParameter::_internal_set_scangain(float value) {
  
  _impl_.scangain_ = value;
}
inline void ChannelParameter::set_scangain(float value) {
  _internal_set_scangain(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.ChannelParameter.scanGain)
}

// float compensatingGain = 7;
inline void ChannelParameter::clear_compensatinggain() {
  _impl_.compensatinggain_ = 0;
}
inline float ChannelParameter::_internal_compensatinggain() const {
  return _impl_.compensatinggain_;
}
inline float ChannelParameter::compensatinggain() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.compensatingGain)
  return _internal_compensatinggain();
}
inline void ChannelParameter::_internal_set_compensatinggain(float value) {
  
  _impl_.compensatinggain_ = value;
}
inline void ChannelParameter::set_compensatinggain(float value) {
  _internal_set_compensatinggain(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.ChannelParameter.compensatingGain)
}

// int32 suppression = 8;
inline void ChannelParameter::clear_suppression() {
  _impl_.suppression_ = 0;
}
inline int32_t ChannelParameter::_internal_suppression() const {
  return _impl_.suppression_;
}
inline int32_t ChannelParameter::suppression() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.suppression)
  return _internal_suppression();
}
inline void ChannelParameter::_internal_set_suppression(int32_t value) {
  
  _impl_.suppression_ = value;
}
inline void ChannelParameter::set_suppression(int32_t value) {
  _internal_set_suppression(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.ChannelParameter.suppression)
}

// .Union.AScan.Proto.DistanceMode distanceMode = 9;
inline void ChannelParameter::clear_distancemode() {
  _impl_.distancemode_ = 0;
}
inline ::Union::AScan::Proto::DistanceMode ChannelParameter::_internal_distancemode() const {
  return static_cast< ::Union::AScan::Proto::DistanceMode >(_impl_.distancemode_);
}
inline ::Union::AScan::Proto::DistanceMode ChannelParameter::distancemode() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.distanceMode)
  return _internal_distancemode();
}
inline void ChannelParameter::_internal_set_distancemode(::Union::AScan::Proto::DistanceMode value) {
  
  _impl_.distancemode_ = value;
}
inline void ChannelParameter::set_distancemode(::Union::AScan::Proto::DistanceMode value) {
  _internal_set_distancemode(value);
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.ChannelParameter.distanceMode)
}

// optional .Union.AScan.Proto.DAC dac = 10;
inline bool ChannelParameter::_internal_has_dac() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dac_ != nullptr);
  return value;
}
inline bool ChannelParameter::has_dac() const {
  return _internal_has_dac();
}
inline void ChannelParameter::clear_dac() {
  if (_impl_.dac_ != nullptr) _impl_.dac_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Union::AScan::Proto::DAC& ChannelParameter::_internal_dac() const {
  const ::Union::AScan::Proto::DAC* p = _impl_.dac_;
  return p != nullptr ? *p : reinterpret_cast<const ::Union::AScan::Proto::DAC&>(
      ::Union::AScan::Proto::_DAC_default_instance_);
}
inline const ::Union::AScan::Proto::DAC& ChannelParameter::dac() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.dac)
  return _internal_dac();
}
inline void ChannelParameter::unsafe_arena_set_allocated_dac(
    ::Union::AScan::Proto::DAC* dac) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dac_);
  }
  _impl_.dac_ = dac;
  if (dac) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Union.AScan.Proto.ChannelParameter.dac)
}
inline ::Union::AScan::Proto::DAC* ChannelParameter::release_dac() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Union::AScan::Proto::DAC* temp = _impl_.dac_;
  _impl_.dac_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Union::AScan::Proto::DAC* ChannelParameter::unsafe_arena_release_dac() {
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.ChannelParameter.dac)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Union::AScan::Proto::DAC* temp = _impl_.dac_;
  _impl_.dac_ = nullptr;
  return temp;
}
inline ::Union::AScan::Proto::DAC* ChannelParameter::_internal_mutable_dac() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.dac_ == nullptr) {
    auto* p = CreateMaybeMessage<::Union::AScan::Proto::DAC>(GetArenaForAllocation());
    _impl_.dac_ = p;
  }
  return _impl_.dac_;
}
inline ::Union::AScan::Proto::DAC* ChannelParameter::mutable_dac() {
  ::Union::AScan::Proto::DAC* _msg = _internal_mutable_dac();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.ChannelParameter.dac)
  return _msg;
}
inline void ChannelParameter::set_allocated_dac(::Union::AScan::Proto::DAC* dac) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dac_;
  }
  if (dac) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dac);
    if (message_arena != submessage_arena) {
      dac = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dac, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dac_ = dac;
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.ChannelParameter.dac)
}

// optional .Union.AScan.Proto.AVG avg = 11;
inline bool ChannelParameter::_internal_has_avg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.avg_ != nullptr);
  return value;
}
inline bool ChannelParameter::has_avg() const {
  return _internal_has_avg();
}
inline void ChannelParameter::clear_avg() {
  if (_impl_.avg_ != nullptr) _impl_.avg_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Union::AScan::Proto::AVG& ChannelParameter::_internal_avg() const {
  const ::Union::AScan::Proto::AVG* p = _impl_.avg_;
  return p != nullptr ? *p : reinterpret_cast<const ::Union::AScan::Proto::AVG&>(
      ::Union::AScan::Proto::_AVG_default_instance_);
}
inline const ::Union::AScan::Proto::AVG& ChannelParameter::avg() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.avg)
  return _internal_avg();
}
inline void ChannelParameter::unsafe_arena_set_allocated_avg(
    ::Union::AScan::Proto::AVG* avg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.avg_);
  }
  _impl_.avg_ = avg;
  if (avg) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Union.AScan.Proto.ChannelParameter.avg)
}
inline ::Union::AScan::Proto::AVG* ChannelParameter::release_avg() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Union::AScan::Proto::AVG* temp = _impl_.avg_;
  _impl_.avg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Union::AScan::Proto::AVG* ChannelParameter::unsafe_arena_release_avg() {
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.ChannelParameter.avg)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Union::AScan::Proto::AVG* temp = _impl_.avg_;
  _impl_.avg_ = nullptr;
  return temp;
}
inline ::Union::AScan::Proto::AVG* ChannelParameter::_internal_mutable_avg() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.avg_ == nullptr) {
    auto* p = CreateMaybeMessage<::Union::AScan::Proto::AVG>(GetArenaForAllocation());
    _impl_.avg_ = p;
  }
  return _impl_.avg_;
}
inline ::Union::AScan::Proto::AVG* ChannelParameter::mutable_avg() {
  ::Union::AScan::Proto::AVG* _msg = _internal_mutable_avg();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.ChannelParameter.avg)
  return _msg;
}
inline void ChannelParameter::set_allocated_avg(::Union::AScan::Proto::AVG* avg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.avg_;
  }
  if (avg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(avg);
    if (message_arena != submessage_arena) {
      avg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, avg, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.avg_ = avg;
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.ChannelParameter.avg)
}

// optional .Union.AScan.Proto.Performance performance = 12;
inline bool ChannelParameter::_internal_has_performance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.performance_ != nullptr);
  return value;
}
inline bool ChannelParameter::has_performance() const {
  return _internal_has_performance();
}
inline void ChannelParameter::clear_performance() {
  if (_impl_.performance_ != nullptr) _impl_.performance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::Union::AScan::Proto::Performance& ChannelParameter::_internal_performance() const {
  const ::Union::AScan::Proto::Performance* p = _impl_.performance_;
  return p != nullptr ? *p : reinterpret_cast<const ::Union::AScan::Proto::Performance&>(
      ::Union::AScan::Proto::_Performance_default_instance_);
}
inline const ::Union::AScan::Proto::Performance& ChannelParameter::performance() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.ChannelParameter.performance)
  return _internal_performance();
}
inline void ChannelParameter::unsafe_arena_set_allocated_performance(
    ::Union::AScan::Proto::Performance* performance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.performance_);
  }
  _impl_.performance_ = performance;
  if (performance) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Union.AScan.Proto.ChannelParameter.performance)
}
inline ::Union::AScan::Proto::Performance* ChannelParameter::release_performance() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Union::AScan::Proto::Performance* temp = _impl_.performance_;
  _impl_.performance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Union::AScan::Proto::Performance* ChannelParameter::unsafe_arena_release_performance() {
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.ChannelParameter.performance)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Union::AScan::Proto::Performance* temp = _impl_.performance_;
  _impl_.performance_ = nullptr;
  return temp;
}
inline ::Union::AScan::Proto::Performance* ChannelParameter::_internal_mutable_performance() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.performance_ == nullptr) {
    auto* p = CreateMaybeMessage<::Union::AScan::Proto::Performance>(GetArenaForAllocation());
    _impl_.performance_ = p;
  }
  return _impl_.performance_;
}
inline ::Union::AScan::Proto::Performance* ChannelParameter::mutable_performance() {
  ::Union::AScan::Proto::Performance* _msg = _internal_mutable_performance();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.ChannelParameter.performance)
  return _msg;
}
inline void ChannelParameter::set_allocated_performance(::Union::AScan::Proto::Performance* performance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.performance_;
  }
  if (performance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(performance);
    if (message_arena != submessage_arena) {
      performance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, performance, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.performance_ = performance;
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.ChannelParameter.performance)
}

// -------------------------------------------------------------------

// AScanPayload

// .Union.AScan.Proto.InstrumentParameter instrumentParameter = 1;
inline bool AScanPayload::_internal_has_instrumentparameter() const {
  return this != internal_default_instance() && _impl_.instrumentparameter_ != nullptr;
}
inline bool AScanPayload::has_instrumentparameter() const {
  return _internal_has_instrumentparameter();
}
inline void AScanPayload::clear_instrumentparameter() {
  if (GetArenaForAllocation() == nullptr && _impl_.instrumentparameter_ != nullptr) {
    delete _impl_.instrumentparameter_;
  }
  _impl_.instrumentparameter_ = nullptr;
}
inline const ::Union::AScan::Proto::InstrumentParameter& AScanPayload::_internal_instrumentparameter() const {
  const ::Union::AScan::Proto::InstrumentParameter* p = _impl_.instrumentparameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::Union::AScan::Proto::InstrumentParameter&>(
      ::Union::AScan::Proto::_InstrumentParameter_default_instance_);
}
inline const ::Union::AScan::Proto::InstrumentParameter& AScanPayload::instrumentparameter() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AScanPayload.instrumentParameter)
  return _internal_instrumentparameter();
}
inline void AScanPayload::unsafe_arena_set_allocated_instrumentparameter(
    ::Union::AScan::Proto::InstrumentParameter* instrumentparameter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrumentparameter_);
  }
  _impl_.instrumentparameter_ = instrumentparameter;
  if (instrumentparameter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Union.AScan.Proto.AScanPayload.instrumentParameter)
}
inline ::Union::AScan::Proto::InstrumentParameter* AScanPayload::release_instrumentparameter() {
  
  ::Union::AScan::Proto::InstrumentParameter* temp = _impl_.instrumentparameter_;
  _impl_.instrumentparameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Union::AScan::Proto::InstrumentParameter* AScanPayload::unsafe_arena_release_instrumentparameter() {
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.AScanPayload.instrumentParameter)
  
  ::Union::AScan::Proto::InstrumentParameter* temp = _impl_.instrumentparameter_;
  _impl_.instrumentparameter_ = nullptr;
  return temp;
}
inline ::Union::AScan::Proto::InstrumentParameter* AScanPayload::_internal_mutable_instrumentparameter() {
  
  if (_impl_.instrumentparameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::Union::AScan::Proto::InstrumentParameter>(GetArenaForAllocation());
    _impl_.instrumentparameter_ = p;
  }
  return _impl_.instrumentparameter_;
}
inline ::Union::AScan::Proto::InstrumentParameter* AScanPayload::mutable_instrumentparameter() {
  ::Union::AScan::Proto::InstrumentParameter* _msg = _internal_mutable_instrumentparameter();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.AScanPayload.instrumentParameter)
  return _msg;
}
inline void AScanPayload::set_allocated_instrumentparameter(::Union::AScan::Proto::InstrumentParameter* instrumentparameter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrumentparameter_;
  }
  if (instrumentparameter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrumentparameter);
    if (message_arena != submessage_arena) {
      instrumentparameter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrumentparameter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instrumentparameter_ = instrumentparameter;
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.AScanPayload.instrumentParameter)
}

// .Union.AScan.Proto.ChannelParameter channelParameter = 2;
inline bool AScanPayload::_internal_has_channelparameter() const {
  return this != internal_default_instance() && _impl_.channelparameter_ != nullptr;
}
inline bool AScanPayload::has_channelparameter() const {
  return _internal_has_channelparameter();
}
inline void AScanPayload::clear_channelparameter() {
  if (GetArenaForAllocation() == nullptr && _impl_.channelparameter_ != nullptr) {
    delete _impl_.channelparameter_;
  }
  _impl_.channelparameter_ = nullptr;
}
inline const ::Union::AScan::Proto::ChannelParameter& AScanPayload::_internal_channelparameter() const {
  const ::Union::AScan::Proto::ChannelParameter* p = _impl_.channelparameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::Union::AScan::Proto::ChannelParameter&>(
      ::Union::AScan::Proto::_ChannelParameter_default_instance_);
}
inline const ::Union::AScan::Proto::ChannelParameter& AScanPayload::channelparameter() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AScanPayload.channelParameter)
  return _internal_channelparameter();
}
inline void AScanPayload::unsafe_arena_set_allocated_channelparameter(
    ::Union::AScan::Proto::ChannelParameter* channelparameter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.channelparameter_);
  }
  _impl_.channelparameter_ = channelparameter;
  if (channelparameter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Union.AScan.Proto.AScanPayload.channelParameter)
}
inline ::Union::AScan::Proto::ChannelParameter* AScanPayload::release_channelparameter() {
  
  ::Union::AScan::Proto::ChannelParameter* temp = _impl_.channelparameter_;
  _impl_.channelparameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Union::AScan::Proto::ChannelParameter* AScanPayload::unsafe_arena_release_channelparameter() {
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.AScanPayload.channelParameter)
  
  ::Union::AScan::Proto::ChannelParameter* temp = _impl_.channelparameter_;
  _impl_.channelparameter_ = nullptr;
  return temp;
}
inline ::Union::AScan::Proto::ChannelParameter* AScanPayload::_internal_mutable_channelparameter() {
  
  if (_impl_.channelparameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::Union::AScan::Proto::ChannelParameter>(GetArenaForAllocation());
    _impl_.channelparameter_ = p;
  }
  return _impl_.channelparameter_;
}
inline ::Union::AScan::Proto::ChannelParameter* AScanPayload::mutable_channelparameter() {
  ::Union::AScan::Proto::ChannelParameter* _msg = _internal_mutable_channelparameter();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.AScanPayload.channelParameter)
  return _msg;
}
inline void AScanPayload::set_allocated_channelparameter(::Union::AScan::Proto::ChannelParameter* channelparameter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.channelparameter_;
  }
  if (channelparameter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(channelparameter);
    if (message_arena != submessage_arena) {
      channelparameter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, channelparameter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.channelparameter_ = channelparameter;
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.AScanPayload.channelParameter)
}

// optional bytes cameraData = 3;
inline bool AScanPayload::_internal_has_cameradata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AScanPayload::has_cameradata() const {
  return _internal_has_cameradata();
}
inline void AScanPayload::clear_cameradata() {
  _impl_.cameradata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AScanPayload::cameradata() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AScanPayload.cameraData)
  return _internal_cameradata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AScanPayload::set_cameradata(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.cameradata_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AScanPayload.cameraData)
}
inline std::string* AScanPayload::mutable_cameradata() {
  std::string* _s = _internal_mutable_cameradata();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.AScanPayload.cameraData)
  return _s;
}
inline const std::string& AScanPayload::_internal_cameradata() const {
  return _impl_.cameradata_.Get();
}
inline void AScanPayload::_internal_set_cameradata(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cameradata_.Set(value, GetArenaForAllocation());
}
inline std::string* AScanPayload::_internal_mutable_cameradata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.cameradata_.Mutable(GetArenaForAllocation());
}
inline std::string* AScanPayload::release_cameradata() {
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.AScanPayload.cameraData)
  if (!_internal_has_cameradata()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.cameradata_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cameradata_.IsDefault()) {
    _impl_.cameradata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AScanPayload::set_allocated_cameradata(std::string* cameradata) {
  if (cameradata != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cameradata_.SetAllocated(cameradata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cameradata_.IsDefault()) {
    _impl_.cameradata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.AScanPayload.cameraData)
}

// -------------------------------------------------------------------

// AScanHead

// string instrumentName = 1;
inline void AScanHead::clear_instrumentname() {
  _impl_.instrumentname_.ClearToEmpty();
}
inline const std::string& AScanHead::instrumentname() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AScanHead.instrumentName)
  return _internal_instrumentname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AScanHead::set_instrumentname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instrumentname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AScanHead.instrumentName)
}
inline std::string* AScanHead::mutable_instrumentname() {
  std::string* _s = _internal_mutable_instrumentname();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.AScanHead.instrumentName)
  return _s;
}
inline const std::string& AScanHead::_internal_instrumentname() const {
  return _impl_.instrumentname_.Get();
}
inline void AScanHead::_internal_set_instrumentname(const std::string& value) {
  
  _impl_.instrumentname_.Set(value, GetArenaForAllocation());
}
inline std::string* AScanHead::_internal_mutable_instrumentname() {
  
  return _impl_.instrumentname_.Mutable(GetArenaForAllocation());
}
inline std::string* AScanHead::release_instrumentname() {
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.AScanHead.instrumentName)
  return _impl_.instrumentname_.Release();
}
inline void AScanHead::set_allocated_instrumentname(std::string* instrumentname) {
  if (instrumentname != nullptr) {
    
  } else {
    
  }
  _impl_.instrumentname_.SetAllocated(instrumentname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instrumentname_.IsDefault()) {
    _impl_.instrumentname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.AScanHead.instrumentName)
}

// string time = 2;
inline void AScanHead::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& AScanHead::time() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AScanHead.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AScanHead::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Union.AScan.Proto.AScanHead.time)
}
inline std::string* AScanHead::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.AScanHead.time)
  return _s;
}
inline const std::string& AScanHead::_internal_time() const {
  return _impl_.time_.Get();
}
inline void AScanHead::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* AScanHead::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* AScanHead::release_time() {
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.AScanHead.time)
  return _impl_.time_.Release();
}
inline void AScanHead::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.AScanHead.time)
}

// -------------------------------------------------------------------

// AScanProtoType

// .Union.AScan.Proto.AScanHead head = 1;
inline bool AScanProtoType::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool AScanProtoType::has_head() const {
  return _internal_has_head();
}
inline void AScanProtoType::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::Union::AScan::Proto::AScanHead& AScanProtoType::_internal_head() const {
  const ::Union::AScan::Proto::AScanHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::Union::AScan::Proto::AScanHead&>(
      ::Union::AScan::Proto::_AScanHead_default_instance_);
}
inline const ::Union::AScan::Proto::AScanHead& AScanProtoType::head() const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AScanProtoType.head)
  return _internal_head();
}
inline void AScanProtoType::unsafe_arena_set_allocated_head(
    ::Union::AScan::Proto::AScanHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Union.AScan.Proto.AScanProtoType.head)
}
inline ::Union::AScan::Proto::AScanHead* AScanProtoType::release_head() {
  
  ::Union::AScan::Proto::AScanHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Union::AScan::Proto::AScanHead* AScanProtoType::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:Union.AScan.Proto.AScanProtoType.head)
  
  ::Union::AScan::Proto::AScanHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::Union::AScan::Proto::AScanHead* AScanProtoType::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::Union::AScan::Proto::AScanHead>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::Union::AScan::Proto::AScanHead* AScanProtoType::mutable_head() {
  ::Union::AScan::Proto::AScanHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.AScanProtoType.head)
  return _msg;
}
inline void AScanProtoType::set_allocated_head(::Union::AScan::Proto::AScanHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:Union.AScan.Proto.AScanProtoType.head)
}

// repeated .Union.AScan.Proto.AScanPayload payload = 2;
inline int AScanProtoType::_internal_payload_size() const {
  return _impl_.payload_.size();
}
inline int AScanProtoType::payload_size() const {
  return _internal_payload_size();
}
inline void AScanProtoType::clear_payload() {
  _impl_.payload_.Clear();
}
inline ::Union::AScan::Proto::AScanPayload* AScanProtoType::mutable_payload(int index) {
  // @@protoc_insertion_point(field_mutable:Union.AScan.Proto.AScanProtoType.payload)
  return _impl_.payload_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Union::AScan::Proto::AScanPayload >*
AScanProtoType::mutable_payload() {
  // @@protoc_insertion_point(field_mutable_list:Union.AScan.Proto.AScanProtoType.payload)
  return &_impl_.payload_;
}
inline const ::Union::AScan::Proto::AScanPayload& AScanProtoType::_internal_payload(int index) const {
  return _impl_.payload_.Get(index);
}
inline const ::Union::AScan::Proto::AScanPayload& AScanProtoType::payload(int index) const {
  // @@protoc_insertion_point(field_get:Union.AScan.Proto.AScanProtoType.payload)
  return _internal_payload(index);
}
inline ::Union::AScan::Proto::AScanPayload* AScanProtoType::_internal_add_payload() {
  return _impl_.payload_.Add();
}
inline ::Union::AScan::Proto::AScanPayload* AScanProtoType::add_payload() {
  ::Union::AScan::Proto::AScanPayload* _add = _internal_add_payload();
  // @@protoc_insertion_point(field_add:Union.AScan.Proto.AScanProtoType.payload)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Union::AScan::Proto::AScanPayload >&
AScanProtoType::payload() const {
  // @@protoc_insertion_point(field_list:Union.AScan.Proto.AScanProtoType.payload)
  return _impl_.payload_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto
}  // namespace AScan
}  // namespace Union

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Union::AScan::Proto::Probe> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Union::AScan::Proto::Probe>() {
  return ::Union::AScan::Proto::Probe_descriptor();
}
template <> struct is_proto_enum< ::Union::AScan::Proto::DACCriteria> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Union::AScan::Proto::DACCriteria>() {
  return ::Union::AScan::Proto::DACCriteria_descriptor();
}
template <> struct is_proto_enum< ::Union::AScan::Proto::DistanceMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Union::AScan::Proto::DistanceMode>() {
  return ::Union::AScan::Proto::DistanceMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_AScan_2eproto
