// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: HDBridge.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_HDBridge_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_HDBridge_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_HDBridge_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_HDBridge_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_HDBridge_2eproto;
namespace Proto {
namespace Union {
namespace HDBridge {
class ChannelParameter;
struct ChannelParameterDefaultTypeInternal;
extern ChannelParameterDefaultTypeInternal _ChannelParameter_default_instance_;
class ConfigData;
struct ConfigDataDefaultTypeInternal;
extern ConfigDataDefaultTypeInternal _ConfigData_default_instance_;
class Gate;
struct GateDefaultTypeInternal;
extern GateDefaultTypeInternal _Gate_default_instance_;
class OneChannelScanData;
struct OneChannelScanDataDefaultTypeInternal;
extern OneChannelScanDataDefaultTypeInternal _OneChannelScanData_default_instance_;
class ScanData;
struct ScanDataDefaultTypeInternal;
extern ScanDataDefaultTypeInternal _ScanData_default_instance_;
class ScanDataVector;
struct ScanDataVectorDefaultTypeInternal;
extern ScanDataVectorDefaultTypeInternal _ScanDataVector_default_instance_;
}  // namespace HDBridge
}  // namespace Union
}  // namespace Proto
PROTOBUF_NAMESPACE_OPEN
template<> ::Proto::Union::HDBridge::ChannelParameter* Arena::CreateMaybeMessage<::Proto::Union::HDBridge::ChannelParameter>(Arena*);
template<> ::Proto::Union::HDBridge::ConfigData* Arena::CreateMaybeMessage<::Proto::Union::HDBridge::ConfigData>(Arena*);
template<> ::Proto::Union::HDBridge::Gate* Arena::CreateMaybeMessage<::Proto::Union::HDBridge::Gate>(Arena*);
template<> ::Proto::Union::HDBridge::OneChannelScanData* Arena::CreateMaybeMessage<::Proto::Union::HDBridge::OneChannelScanData>(Arena*);
template<> ::Proto::Union::HDBridge::ScanData* Arena::CreateMaybeMessage<::Proto::Union::HDBridge::ScanData>(Arena*);
template<> ::Proto::Union::HDBridge::ScanDataVector* Arena::CreateMaybeMessage<::Proto::Union::HDBridge::ScanDataVector>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Proto {
namespace Union {
namespace HDBridge {

// ===================================================================

class Gate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.Union.HDBridge.Gate) */ {
 public:
  inline Gate() : Gate(nullptr) {}
  ~Gate() override;
  explicit PROTOBUF_CONSTEXPR Gate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Gate(const Gate& from);
  Gate(Gate&& from) noexcept
    : Gate() {
    *this = ::std::move(from);
  }

  inline Gate& operator=(const Gate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gate& operator=(Gate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gate* internal_default_instance() {
    return reinterpret_cast<const Gate*>(
               &_Gate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Gate& a, Gate& b) {
    a.Swap(&b);
  }
  inline void Swap(Gate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Gate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Gate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Gate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Gate& from) {
    Gate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.Union.HDBridge.Gate";
  }
  protected:
  explicit Gate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kIndexFieldNumber = 4,
  };
  // double pos = 1;
  void clear_pos();
  double pos() const;
  void set_pos(double value);
  private:
  double _internal_pos() const;
  void _internal_set_pos(double value);
  public:

  // double width = 2;
  void clear_width();
  double width() const;
  void set_width(double value);
  private:
  double _internal_width() const;
  void _internal_set_width(double value);
  public:

  // double height = 3;
  void clear_height();
  double height() const;
  void set_height(double value);
  private:
  double _internal_height() const;
  void _internal_set_height(double value);
  public:

  // uint32 index = 4;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Proto.Union.HDBridge.Gate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double pos_;
    double width_;
    double height_;
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_HDBridge_2eproto;
};
// -------------------------------------------------------------------

class ChannelParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.Union.HDBridge.ChannelParameter) */ {
 public:
  inline ChannelParameter() : ChannelParameter(nullptr) {}
  ~ChannelParameter() override;
  explicit PROTOBUF_CONSTEXPR ChannelParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChannelParameter(const ChannelParameter& from);
  ChannelParameter(ChannelParameter&& from) noexcept
    : ChannelParameter() {
    *this = ::std::move(from);
  }

  inline ChannelParameter& operator=(const ChannelParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelParameter& operator=(ChannelParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelParameter* internal_default_instance() {
    return reinterpret_cast<const ChannelParameter*>(
               &_ChannelParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ChannelParameter& a, ChannelParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChannelParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChannelParameter& from) {
    ChannelParameter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.Union.HDBridge.ChannelParameter";
  }
  protected:
  explicit ChannelParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGatesFieldNumber = 11,
    kSoundVelocityFieldNumber = 1,
    kZeroBiasFieldNumber = 2,
    kPulseWidthFieldNumber = 3,
    kSamplingDelayFieldNumber = 4,
    kSamplingDepthFieldNumber = 5,
    kGainFieldNumber = 7,
    kSamplingFactorFieldNumber = 6,
    kFilterBandFieldNumber = 8,
    kDemoduModeFieldNumber = 9,
    kPhaseReverseFieldNumber = 10,
  };
  // repeated .Proto.Union.HDBridge.Gate gates = 11;
  int gates_size() const;
  private:
  int _internal_gates_size() const;
  public:
  void clear_gates();
  ::Proto::Union::HDBridge::Gate* mutable_gates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::Gate >*
      mutable_gates();
  private:
  const ::Proto::Union::HDBridge::Gate& _internal_gates(int index) const;
  ::Proto::Union::HDBridge::Gate* _internal_add_gates();
  public:
  const ::Proto::Union::HDBridge::Gate& gates(int index) const;
  ::Proto::Union::HDBridge::Gate* add_gates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::Gate >&
      gates() const;

  // double sound_velocity = 1;
  void clear_sound_velocity();
  double sound_velocity() const;
  void set_sound_velocity(double value);
  private:
  double _internal_sound_velocity() const;
  void _internal_set_sound_velocity(double value);
  public:

  // double zero_bias = 2;
  void clear_zero_bias();
  double zero_bias() const;
  void set_zero_bias(double value);
  private:
  double _internal_zero_bias() const;
  void _internal_set_zero_bias(double value);
  public:

  // double pulse_width = 3;
  void clear_pulse_width();
  double pulse_width() const;
  void set_pulse_width(double value);
  private:
  double _internal_pulse_width() const;
  void _internal_set_pulse_width(double value);
  public:

  // double sampling_delay = 4;
  void clear_sampling_delay();
  double sampling_delay() const;
  void set_sampling_delay(double value);
  private:
  double _internal_sampling_delay() const;
  void _internal_set_sampling_delay(double value);
  public:

  // double sampling_depth = 5;
  void clear_sampling_depth();
  double sampling_depth() const;
  void set_sampling_depth(double value);
  private:
  double _internal_sampling_depth() const;
  void _internal_set_sampling_depth(double value);
  public:

  // double gain = 7;
  void clear_gain();
  double gain() const;
  void set_gain(double value);
  private:
  double _internal_gain() const;
  void _internal_set_gain(double value);
  public:

  // int32 sampling_factor = 6;
  void clear_sampling_factor();
  int32_t sampling_factor() const;
  void set_sampling_factor(int32_t value);
  private:
  int32_t _internal_sampling_factor() const;
  void _internal_set_sampling_factor(int32_t value);
  public:

  // int32 filter_band = 8;
  void clear_filter_band();
  int32_t filter_band() const;
  void set_filter_band(int32_t value);
  private:
  int32_t _internal_filter_band() const;
  void _internal_set_filter_band(int32_t value);
  public:

  // int32 demodu_mode = 9;
  void clear_demodu_mode();
  int32_t demodu_mode() const;
  void set_demodu_mode(int32_t value);
  private:
  int32_t _internal_demodu_mode() const;
  void _internal_set_demodu_mode(int32_t value);
  public:

  // bool phase_reverse = 10;
  void clear_phase_reverse();
  bool phase_reverse() const;
  void set_phase_reverse(bool value);
  private:
  bool _internal_phase_reverse() const;
  void _internal_set_phase_reverse(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Proto.Union.HDBridge.ChannelParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::Gate > gates_;
    double sound_velocity_;
    double zero_bias_;
    double pulse_width_;
    double sampling_delay_;
    double sampling_depth_;
    double gain_;
    int32_t sampling_factor_;
    int32_t filter_band_;
    int32_t demodu_mode_;
    bool phase_reverse_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_HDBridge_2eproto;
};
// -------------------------------------------------------------------

class OneChannelScanData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.Union.HDBridge.OneChannelScanData) */ {
 public:
  inline OneChannelScanData() : OneChannelScanData(nullptr) {}
  ~OneChannelScanData() override;
  explicit PROTOBUF_CONSTEXPR OneChannelScanData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OneChannelScanData(const OneChannelScanData& from);
  OneChannelScanData(OneChannelScanData&& from) noexcept
    : OneChannelScanData() {
    *this = ::std::move(from);
  }

  inline OneChannelScanData& operator=(const OneChannelScanData& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneChannelScanData& operator=(OneChannelScanData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneChannelScanData& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneChannelScanData* internal_default_instance() {
    return reinterpret_cast<const OneChannelScanData*>(
               &_OneChannelScanData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OneChannelScanData& a, OneChannelScanData& b) {
    a.Swap(&b);
  }
  inline void Swap(OneChannelScanData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneChannelScanData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneChannelScanData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OneChannelScanData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OneChannelScanData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OneChannelScanData& from) {
    OneChannelScanData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OneChannelScanData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.Union.HDBridge.OneChannelScanData";
  }
  protected:
  explicit OneChannelScanData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGatesFieldNumber = 6,
    kAscanDataFieldNumber = 5,
    kPakcageIndexFieldNumber = 1,
    kChannelFieldNumber = 2,
    kAxisOffsetFieldNumber = 3,
    kAxisLengthFieldNumber = 4,
  };
  // repeated .Proto.Union.HDBridge.Gate gates = 6;
  int gates_size() const;
  private:
  int _internal_gates_size() const;
  public:
  void clear_gates();
  ::Proto::Union::HDBridge::Gate* mutable_gates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::Gate >*
      mutable_gates();
  private:
  const ::Proto::Union::HDBridge::Gate& _internal_gates(int index) const;
  ::Proto::Union::HDBridge::Gate* _internal_add_gates();
  public:
  const ::Proto::Union::HDBridge::Gate& gates(int index) const;
  ::Proto::Union::HDBridge::Gate* add_gates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::Gate >&
      gates() const;

  // bytes ascan_data = 5;
  void clear_ascan_data();
  const std::string& ascan_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ascan_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ascan_data();
  PROTOBUF_NODISCARD std::string* release_ascan_data();
  void set_allocated_ascan_data(std::string* ascan_data);
  private:
  const std::string& _internal_ascan_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ascan_data(const std::string& value);
  std::string* _internal_mutable_ascan_data();
  public:

  // int32 pakcage_index = 1;
  void clear_pakcage_index();
  int32_t pakcage_index() const;
  void set_pakcage_index(int32_t value);
  private:
  int32_t _internal_pakcage_index() const;
  void _internal_set_pakcage_index(int32_t value);
  public:

  // int32 channel = 2;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // double axis_offset = 3;
  void clear_axis_offset();
  double axis_offset() const;
  void set_axis_offset(double value);
  private:
  double _internal_axis_offset() const;
  void _internal_set_axis_offset(double value);
  public:

  // double axis_length = 4;
  void clear_axis_length();
  double axis_length() const;
  void set_axis_length(double value);
  private:
  double _internal_axis_length() const;
  void _internal_set_axis_length(double value);
  public:

  // @@protoc_insertion_point(class_scope:Proto.Union.HDBridge.OneChannelScanData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::Gate > gates_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ascan_data_;
    int32_t pakcage_index_;
    int32_t channel_;
    double axis_offset_;
    double axis_length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_HDBridge_2eproto;
};
// -------------------------------------------------------------------

class ConfigData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.Union.HDBridge.ConfigData) */ {
 public:
  inline ConfigData() : ConfigData(nullptr) {}
  ~ConfigData() override;
  explicit PROTOBUF_CONSTEXPR ConfigData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigData(const ConfigData& from);
  ConfigData(ConfigData&& from) noexcept
    : ConfigData() {
    *this = ::std::move(from);
  }

  inline ConfigData& operator=(const ConfigData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigData& operator=(ConfigData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigData* internal_default_instance() {
    return reinterpret_cast<const ConfigData*>(
               &_ConfigData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ConfigData& a, ConfigData& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfigData& from) {
    ConfigData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.Union.HDBridge.ConfigData";
  }
  protected:
  explicit ConfigData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelParametersFieldNumber = 5,
    kRepeatFreqencyFieldNumber = 1,
    kEmitVoltageFieldNumber = 2,
    kChannelFlagFieldNumber = 3,
    kDamperFlagFieldNumber = 4,
  };
  // repeated .Proto.Union.HDBridge.ChannelParameter channel_parameters = 5;
  int channel_parameters_size() const;
  private:
  int _internal_channel_parameters_size() const;
  public:
  void clear_channel_parameters();
  ::Proto::Union::HDBridge::ChannelParameter* mutable_channel_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::ChannelParameter >*
      mutable_channel_parameters();
  private:
  const ::Proto::Union::HDBridge::ChannelParameter& _internal_channel_parameters(int index) const;
  ::Proto::Union::HDBridge::ChannelParameter* _internal_add_channel_parameters();
  public:
  const ::Proto::Union::HDBridge::ChannelParameter& channel_parameters(int index) const;
  ::Proto::Union::HDBridge::ChannelParameter* add_channel_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::ChannelParameter >&
      channel_parameters() const;

  // int32 repeat_freqency = 1;
  void clear_repeat_freqency();
  int32_t repeat_freqency() const;
  void set_repeat_freqency(int32_t value);
  private:
  int32_t _internal_repeat_freqency() const;
  void _internal_set_repeat_freqency(int32_t value);
  public:

  // int32 emit_voltage = 2;
  void clear_emit_voltage();
  int32_t emit_voltage() const;
  void set_emit_voltage(int32_t value);
  private:
  int32_t _internal_emit_voltage() const;
  void _internal_set_emit_voltage(int32_t value);
  public:

  // uint32 channel_flag = 3;
  void clear_channel_flag();
  uint32_t channel_flag() const;
  void set_channel_flag(uint32_t value);
  private:
  uint32_t _internal_channel_flag() const;
  void _internal_set_channel_flag(uint32_t value);
  public:

  // int32 damper_flag = 4;
  void clear_damper_flag();
  int32_t damper_flag() const;
  void set_damper_flag(int32_t value);
  private:
  int32_t _internal_damper_flag() const;
  void _internal_set_damper_flag(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Proto.Union.HDBridge.ConfigData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::ChannelParameter > channel_parameters_;
    int32_t repeat_freqency_;
    int32_t emit_voltage_;
    uint32_t channel_flag_;
    int32_t damper_flag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_HDBridge_2eproto;
};
// -------------------------------------------------------------------

class ScanData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.Union.HDBridge.ScanData) */ {
 public:
  inline ScanData() : ScanData(nullptr) {}
  ~ScanData() override;
  explicit PROTOBUF_CONSTEXPR ScanData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScanData(const ScanData& from);
  ScanData(ScanData&& from) noexcept
    : ScanData() {
    *this = ::std::move(from);
  }

  inline ScanData& operator=(const ScanData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScanData& operator=(ScanData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScanData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScanData* internal_default_instance() {
    return reinterpret_cast<const ScanData*>(
               &_ScanData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ScanData& a, ScanData& b) {
    a.Swap(&b);
  }
  inline void Swap(ScanData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScanData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScanData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScanData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScanData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ScanData& from) {
    ScanData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScanData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.Union.HDBridge.ScanData";
  }
  protected:
  explicit ScanData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelDataFieldNumber = 1,
  };
  // repeated .Proto.Union.HDBridge.OneChannelScanData channel_data = 1;
  int channel_data_size() const;
  private:
  int _internal_channel_data_size() const;
  public:
  void clear_channel_data();
  ::Proto::Union::HDBridge::OneChannelScanData* mutable_channel_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::OneChannelScanData >*
      mutable_channel_data();
  private:
  const ::Proto::Union::HDBridge::OneChannelScanData& _internal_channel_data(int index) const;
  ::Proto::Union::HDBridge::OneChannelScanData* _internal_add_channel_data();
  public:
  const ::Proto::Union::HDBridge::OneChannelScanData& channel_data(int index) const;
  ::Proto::Union::HDBridge::OneChannelScanData* add_channel_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::OneChannelScanData >&
      channel_data() const;

  // @@protoc_insertion_point(class_scope:Proto.Union.HDBridge.ScanData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::OneChannelScanData > channel_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_HDBridge_2eproto;
};
// -------------------------------------------------------------------

class ScanDataVector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.Union.HDBridge.ScanDataVector) */ {
 public:
  inline ScanDataVector() : ScanDataVector(nullptr) {}
  ~ScanDataVector() override;
  explicit PROTOBUF_CONSTEXPR ScanDataVector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScanDataVector(const ScanDataVector& from);
  ScanDataVector(ScanDataVector&& from) noexcept
    : ScanDataVector() {
    *this = ::std::move(from);
  }

  inline ScanDataVector& operator=(const ScanDataVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScanDataVector& operator=(ScanDataVector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScanDataVector& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScanDataVector* internal_default_instance() {
    return reinterpret_cast<const ScanDataVector*>(
               &_ScanDataVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ScanDataVector& a, ScanDataVector& b) {
    a.Swap(&b);
  }
  inline void Swap(ScanDataVector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScanDataVector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScanDataVector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScanDataVector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScanDataVector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ScanDataVector& from) {
    ScanDataVector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScanDataVector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.Union.HDBridge.ScanDataVector";
  }
  protected:
  explicit ScanDataVector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScanDataFieldNumber = 1,
  };
  // repeated .Proto.Union.HDBridge.ScanData scan_data = 1;
  int scan_data_size() const;
  private:
  int _internal_scan_data_size() const;
  public:
  void clear_scan_data();
  ::Proto::Union::HDBridge::ScanData* mutable_scan_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::ScanData >*
      mutable_scan_data();
  private:
  const ::Proto::Union::HDBridge::ScanData& _internal_scan_data(int index) const;
  ::Proto::Union::HDBridge::ScanData* _internal_add_scan_data();
  public:
  const ::Proto::Union::HDBridge::ScanData& scan_data(int index) const;
  ::Proto::Union::HDBridge::ScanData* add_scan_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::ScanData >&
      scan_data() const;

  // @@protoc_insertion_point(class_scope:Proto.Union.HDBridge.ScanDataVector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::ScanData > scan_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_HDBridge_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Gate

// double pos = 1;
inline void Gate::clear_pos() {
  _impl_.pos_ = 0;
}
inline double Gate::_internal_pos() const {
  return _impl_.pos_;
}
inline double Gate::pos() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.Gate.pos)
  return _internal_pos();
}
inline void Gate::_internal_set_pos(double value) {
  
  _impl_.pos_ = value;
}
inline void Gate::set_pos(double value) {
  _internal_set_pos(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.Gate.pos)
}

// double width = 2;
inline void Gate::clear_width() {
  _impl_.width_ = 0;
}
inline double Gate::_internal_width() const {
  return _impl_.width_;
}
inline double Gate::width() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.Gate.width)
  return _internal_width();
}
inline void Gate::_internal_set_width(double value) {
  
  _impl_.width_ = value;
}
inline void Gate::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.Gate.width)
}

// double height = 3;
inline void Gate::clear_height() {
  _impl_.height_ = 0;
}
inline double Gate::_internal_height() const {
  return _impl_.height_;
}
inline double Gate::height() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.Gate.height)
  return _internal_height();
}
inline void Gate::_internal_set_height(double value) {
  
  _impl_.height_ = value;
}
inline void Gate::set_height(double value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.Gate.height)
}

// uint32 index = 4;
inline void Gate::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t Gate::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t Gate::index() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.Gate.index)
  return _internal_index();
}
inline void Gate::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void Gate::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.Gate.index)
}

// -------------------------------------------------------------------

// ChannelParameter

// double sound_velocity = 1;
inline void ChannelParameter::clear_sound_velocity() {
  _impl_.sound_velocity_ = 0;
}
inline double ChannelParameter::_internal_sound_velocity() const {
  return _impl_.sound_velocity_;
}
inline double ChannelParameter::sound_velocity() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ChannelParameter.sound_velocity)
  return _internal_sound_velocity();
}
inline void ChannelParameter::_internal_set_sound_velocity(double value) {
  
  _impl_.sound_velocity_ = value;
}
inline void ChannelParameter::set_sound_velocity(double value) {
  _internal_set_sound_velocity(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.ChannelParameter.sound_velocity)
}

// double zero_bias = 2;
inline void ChannelParameter::clear_zero_bias() {
  _impl_.zero_bias_ = 0;
}
inline double ChannelParameter::_internal_zero_bias() const {
  return _impl_.zero_bias_;
}
inline double ChannelParameter::zero_bias() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ChannelParameter.zero_bias)
  return _internal_zero_bias();
}
inline void ChannelParameter::_internal_set_zero_bias(double value) {
  
  _impl_.zero_bias_ = value;
}
inline void ChannelParameter::set_zero_bias(double value) {
  _internal_set_zero_bias(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.ChannelParameter.zero_bias)
}

// double pulse_width = 3;
inline void ChannelParameter::clear_pulse_width() {
  _impl_.pulse_width_ = 0;
}
inline double ChannelParameter::_internal_pulse_width() const {
  return _impl_.pulse_width_;
}
inline double ChannelParameter::pulse_width() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ChannelParameter.pulse_width)
  return _internal_pulse_width();
}
inline void ChannelParameter::_internal_set_pulse_width(double value) {
  
  _impl_.pulse_width_ = value;
}
inline void ChannelParameter::set_pulse_width(double value) {
  _internal_set_pulse_width(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.ChannelParameter.pulse_width)
}

// double sampling_delay = 4;
inline void ChannelParameter::clear_sampling_delay() {
  _impl_.sampling_delay_ = 0;
}
inline double ChannelParameter::_internal_sampling_delay() const {
  return _impl_.sampling_delay_;
}
inline double ChannelParameter::sampling_delay() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ChannelParameter.sampling_delay)
  return _internal_sampling_delay();
}
inline void ChannelParameter::_internal_set_sampling_delay(double value) {
  
  _impl_.sampling_delay_ = value;
}
inline void ChannelParameter::set_sampling_delay(double value) {
  _internal_set_sampling_delay(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.ChannelParameter.sampling_delay)
}

// double sampling_depth = 5;
inline void ChannelParameter::clear_sampling_depth() {
  _impl_.sampling_depth_ = 0;
}
inline double ChannelParameter::_internal_sampling_depth() const {
  return _impl_.sampling_depth_;
}
inline double ChannelParameter::sampling_depth() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ChannelParameter.sampling_depth)
  return _internal_sampling_depth();
}
inline void ChannelParameter::_internal_set_sampling_depth(double value) {
  
  _impl_.sampling_depth_ = value;
}
inline void ChannelParameter::set_sampling_depth(double value) {
  _internal_set_sampling_depth(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.ChannelParameter.sampling_depth)
}

// int32 sampling_factor = 6;
inline void ChannelParameter::clear_sampling_factor() {
  _impl_.sampling_factor_ = 0;
}
inline int32_t ChannelParameter::_internal_sampling_factor() const {
  return _impl_.sampling_factor_;
}
inline int32_t ChannelParameter::sampling_factor() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ChannelParameter.sampling_factor)
  return _internal_sampling_factor();
}
inline void ChannelParameter::_internal_set_sampling_factor(int32_t value) {
  
  _impl_.sampling_factor_ = value;
}
inline void ChannelParameter::set_sampling_factor(int32_t value) {
  _internal_set_sampling_factor(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.ChannelParameter.sampling_factor)
}

// double gain = 7;
inline void ChannelParameter::clear_gain() {
  _impl_.gain_ = 0;
}
inline double ChannelParameter::_internal_gain() const {
  return _impl_.gain_;
}
inline double ChannelParameter::gain() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ChannelParameter.gain)
  return _internal_gain();
}
inline void ChannelParameter::_internal_set_gain(double value) {
  
  _impl_.gain_ = value;
}
inline void ChannelParameter::set_gain(double value) {
  _internal_set_gain(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.ChannelParameter.gain)
}

// int32 filter_band = 8;
inline void ChannelParameter::clear_filter_band() {
  _impl_.filter_band_ = 0;
}
inline int32_t ChannelParameter::_internal_filter_band() const {
  return _impl_.filter_band_;
}
inline int32_t ChannelParameter::filter_band() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ChannelParameter.filter_band)
  return _internal_filter_band();
}
inline void ChannelParameter::_internal_set_filter_band(int32_t value) {
  
  _impl_.filter_band_ = value;
}
inline void ChannelParameter::set_filter_band(int32_t value) {
  _internal_set_filter_band(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.ChannelParameter.filter_band)
}

// int32 demodu_mode = 9;
inline void ChannelParameter::clear_demodu_mode() {
  _impl_.demodu_mode_ = 0;
}
inline int32_t ChannelParameter::_internal_demodu_mode() const {
  return _impl_.demodu_mode_;
}
inline int32_t ChannelParameter::demodu_mode() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ChannelParameter.demodu_mode)
  return _internal_demodu_mode();
}
inline void ChannelParameter::_internal_set_demodu_mode(int32_t value) {
  
  _impl_.demodu_mode_ = value;
}
inline void ChannelParameter::set_demodu_mode(int32_t value) {
  _internal_set_demodu_mode(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.ChannelParameter.demodu_mode)
}

// bool phase_reverse = 10;
inline void ChannelParameter::clear_phase_reverse() {
  _impl_.phase_reverse_ = false;
}
inline bool ChannelParameter::_internal_phase_reverse() const {
  return _impl_.phase_reverse_;
}
inline bool ChannelParameter::phase_reverse() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ChannelParameter.phase_reverse)
  return _internal_phase_reverse();
}
inline void ChannelParameter::_internal_set_phase_reverse(bool value) {
  
  _impl_.phase_reverse_ = value;
}
inline void ChannelParameter::set_phase_reverse(bool value) {
  _internal_set_phase_reverse(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.ChannelParameter.phase_reverse)
}

// repeated .Proto.Union.HDBridge.Gate gates = 11;
inline int ChannelParameter::_internal_gates_size() const {
  return _impl_.gates_.size();
}
inline int ChannelParameter::gates_size() const {
  return _internal_gates_size();
}
inline void ChannelParameter::clear_gates() {
  _impl_.gates_.Clear();
}
inline ::Proto::Union::HDBridge::Gate* ChannelParameter::mutable_gates(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.Union.HDBridge.ChannelParameter.gates)
  return _impl_.gates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::Gate >*
ChannelParameter::mutable_gates() {
  // @@protoc_insertion_point(field_mutable_list:Proto.Union.HDBridge.ChannelParameter.gates)
  return &_impl_.gates_;
}
inline const ::Proto::Union::HDBridge::Gate& ChannelParameter::_internal_gates(int index) const {
  return _impl_.gates_.Get(index);
}
inline const ::Proto::Union::HDBridge::Gate& ChannelParameter::gates(int index) const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ChannelParameter.gates)
  return _internal_gates(index);
}
inline ::Proto::Union::HDBridge::Gate* ChannelParameter::_internal_add_gates() {
  return _impl_.gates_.Add();
}
inline ::Proto::Union::HDBridge::Gate* ChannelParameter::add_gates() {
  ::Proto::Union::HDBridge::Gate* _add = _internal_add_gates();
  // @@protoc_insertion_point(field_add:Proto.Union.HDBridge.ChannelParameter.gates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::Gate >&
ChannelParameter::gates() const {
  // @@protoc_insertion_point(field_list:Proto.Union.HDBridge.ChannelParameter.gates)
  return _impl_.gates_;
}

// -------------------------------------------------------------------

// OneChannelScanData

// int32 pakcage_index = 1;
inline void OneChannelScanData::clear_pakcage_index() {
  _impl_.pakcage_index_ = 0;
}
inline int32_t OneChannelScanData::_internal_pakcage_index() const {
  return _impl_.pakcage_index_;
}
inline int32_t OneChannelScanData::pakcage_index() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.OneChannelScanData.pakcage_index)
  return _internal_pakcage_index();
}
inline void OneChannelScanData::_internal_set_pakcage_index(int32_t value) {
  
  _impl_.pakcage_index_ = value;
}
inline void OneChannelScanData::set_pakcage_index(int32_t value) {
  _internal_set_pakcage_index(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.OneChannelScanData.pakcage_index)
}

// int32 channel = 2;
inline void OneChannelScanData::clear_channel() {
  _impl_.channel_ = 0;
}
inline int32_t OneChannelScanData::_internal_channel() const {
  return _impl_.channel_;
}
inline int32_t OneChannelScanData::channel() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.OneChannelScanData.channel)
  return _internal_channel();
}
inline void OneChannelScanData::_internal_set_channel(int32_t value) {
  
  _impl_.channel_ = value;
}
inline void OneChannelScanData::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.OneChannelScanData.channel)
}

// double axis_offset = 3;
inline void OneChannelScanData::clear_axis_offset() {
  _impl_.axis_offset_ = 0;
}
inline double OneChannelScanData::_internal_axis_offset() const {
  return _impl_.axis_offset_;
}
inline double OneChannelScanData::axis_offset() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.OneChannelScanData.axis_offset)
  return _internal_axis_offset();
}
inline void OneChannelScanData::_internal_set_axis_offset(double value) {
  
  _impl_.axis_offset_ = value;
}
inline void OneChannelScanData::set_axis_offset(double value) {
  _internal_set_axis_offset(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.OneChannelScanData.axis_offset)
}

// double axis_length = 4;
inline void OneChannelScanData::clear_axis_length() {
  _impl_.axis_length_ = 0;
}
inline double OneChannelScanData::_internal_axis_length() const {
  return _impl_.axis_length_;
}
inline double OneChannelScanData::axis_length() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.OneChannelScanData.axis_length)
  return _internal_axis_length();
}
inline void OneChannelScanData::_internal_set_axis_length(double value) {
  
  _impl_.axis_length_ = value;
}
inline void OneChannelScanData::set_axis_length(double value) {
  _internal_set_axis_length(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.OneChannelScanData.axis_length)
}

// bytes ascan_data = 5;
inline void OneChannelScanData::clear_ascan_data() {
  _impl_.ascan_data_.ClearToEmpty();
}
inline const std::string& OneChannelScanData::ascan_data() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.OneChannelScanData.ascan_data)
  return _internal_ascan_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OneChannelScanData::set_ascan_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ascan_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.OneChannelScanData.ascan_data)
}
inline std::string* OneChannelScanData::mutable_ascan_data() {
  std::string* _s = _internal_mutable_ascan_data();
  // @@protoc_insertion_point(field_mutable:Proto.Union.HDBridge.OneChannelScanData.ascan_data)
  return _s;
}
inline const std::string& OneChannelScanData::_internal_ascan_data() const {
  return _impl_.ascan_data_.Get();
}
inline void OneChannelScanData::_internal_set_ascan_data(const std::string& value) {
  
  _impl_.ascan_data_.Set(value, GetArenaForAllocation());
}
inline std::string* OneChannelScanData::_internal_mutable_ascan_data() {
  
  return _impl_.ascan_data_.Mutable(GetArenaForAllocation());
}
inline std::string* OneChannelScanData::release_ascan_data() {
  // @@protoc_insertion_point(field_release:Proto.Union.HDBridge.OneChannelScanData.ascan_data)
  return _impl_.ascan_data_.Release();
}
inline void OneChannelScanData::set_allocated_ascan_data(std::string* ascan_data) {
  if (ascan_data != nullptr) {
    
  } else {
    
  }
  _impl_.ascan_data_.SetAllocated(ascan_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ascan_data_.IsDefault()) {
    _impl_.ascan_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Proto.Union.HDBridge.OneChannelScanData.ascan_data)
}

// repeated .Proto.Union.HDBridge.Gate gates = 6;
inline int OneChannelScanData::_internal_gates_size() const {
  return _impl_.gates_.size();
}
inline int OneChannelScanData::gates_size() const {
  return _internal_gates_size();
}
inline void OneChannelScanData::clear_gates() {
  _impl_.gates_.Clear();
}
inline ::Proto::Union::HDBridge::Gate* OneChannelScanData::mutable_gates(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.Union.HDBridge.OneChannelScanData.gates)
  return _impl_.gates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::Gate >*
OneChannelScanData::mutable_gates() {
  // @@protoc_insertion_point(field_mutable_list:Proto.Union.HDBridge.OneChannelScanData.gates)
  return &_impl_.gates_;
}
inline const ::Proto::Union::HDBridge::Gate& OneChannelScanData::_internal_gates(int index) const {
  return _impl_.gates_.Get(index);
}
inline const ::Proto::Union::HDBridge::Gate& OneChannelScanData::gates(int index) const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.OneChannelScanData.gates)
  return _internal_gates(index);
}
inline ::Proto::Union::HDBridge::Gate* OneChannelScanData::_internal_add_gates() {
  return _impl_.gates_.Add();
}
inline ::Proto::Union::HDBridge::Gate* OneChannelScanData::add_gates() {
  ::Proto::Union::HDBridge::Gate* _add = _internal_add_gates();
  // @@protoc_insertion_point(field_add:Proto.Union.HDBridge.OneChannelScanData.gates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::Gate >&
OneChannelScanData::gates() const {
  // @@protoc_insertion_point(field_list:Proto.Union.HDBridge.OneChannelScanData.gates)
  return _impl_.gates_;
}

// -------------------------------------------------------------------

// ConfigData

// int32 repeat_freqency = 1;
inline void ConfigData::clear_repeat_freqency() {
  _impl_.repeat_freqency_ = 0;
}
inline int32_t ConfigData::_internal_repeat_freqency() const {
  return _impl_.repeat_freqency_;
}
inline int32_t ConfigData::repeat_freqency() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ConfigData.repeat_freqency)
  return _internal_repeat_freqency();
}
inline void ConfigData::_internal_set_repeat_freqency(int32_t value) {
  
  _impl_.repeat_freqency_ = value;
}
inline void ConfigData::set_repeat_freqency(int32_t value) {
  _internal_set_repeat_freqency(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.ConfigData.repeat_freqency)
}

// int32 emit_voltage = 2;
inline void ConfigData::clear_emit_voltage() {
  _impl_.emit_voltage_ = 0;
}
inline int32_t ConfigData::_internal_emit_voltage() const {
  return _impl_.emit_voltage_;
}
inline int32_t ConfigData::emit_voltage() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ConfigData.emit_voltage)
  return _internal_emit_voltage();
}
inline void ConfigData::_internal_set_emit_voltage(int32_t value) {
  
  _impl_.emit_voltage_ = value;
}
inline void ConfigData::set_emit_voltage(int32_t value) {
  _internal_set_emit_voltage(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.ConfigData.emit_voltage)
}

// uint32 channel_flag = 3;
inline void ConfigData::clear_channel_flag() {
  _impl_.channel_flag_ = 0u;
}
inline uint32_t ConfigData::_internal_channel_flag() const {
  return _impl_.channel_flag_;
}
inline uint32_t ConfigData::channel_flag() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ConfigData.channel_flag)
  return _internal_channel_flag();
}
inline void ConfigData::_internal_set_channel_flag(uint32_t value) {
  
  _impl_.channel_flag_ = value;
}
inline void ConfigData::set_channel_flag(uint32_t value) {
  _internal_set_channel_flag(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.ConfigData.channel_flag)
}

// int32 damper_flag = 4;
inline void ConfigData::clear_damper_flag() {
  _impl_.damper_flag_ = 0;
}
inline int32_t ConfigData::_internal_damper_flag() const {
  return _impl_.damper_flag_;
}
inline int32_t ConfigData::damper_flag() const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ConfigData.damper_flag)
  return _internal_damper_flag();
}
inline void ConfigData::_internal_set_damper_flag(int32_t value) {
  
  _impl_.damper_flag_ = value;
}
inline void ConfigData::set_damper_flag(int32_t value) {
  _internal_set_damper_flag(value);
  // @@protoc_insertion_point(field_set:Proto.Union.HDBridge.ConfigData.damper_flag)
}

// repeated .Proto.Union.HDBridge.ChannelParameter channel_parameters = 5;
inline int ConfigData::_internal_channel_parameters_size() const {
  return _impl_.channel_parameters_.size();
}
inline int ConfigData::channel_parameters_size() const {
  return _internal_channel_parameters_size();
}
inline void ConfigData::clear_channel_parameters() {
  _impl_.channel_parameters_.Clear();
}
inline ::Proto::Union::HDBridge::ChannelParameter* ConfigData::mutable_channel_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.Union.HDBridge.ConfigData.channel_parameters)
  return _impl_.channel_parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::ChannelParameter >*
ConfigData::mutable_channel_parameters() {
  // @@protoc_insertion_point(field_mutable_list:Proto.Union.HDBridge.ConfigData.channel_parameters)
  return &_impl_.channel_parameters_;
}
inline const ::Proto::Union::HDBridge::ChannelParameter& ConfigData::_internal_channel_parameters(int index) const {
  return _impl_.channel_parameters_.Get(index);
}
inline const ::Proto::Union::HDBridge::ChannelParameter& ConfigData::channel_parameters(int index) const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ConfigData.channel_parameters)
  return _internal_channel_parameters(index);
}
inline ::Proto::Union::HDBridge::ChannelParameter* ConfigData::_internal_add_channel_parameters() {
  return _impl_.channel_parameters_.Add();
}
inline ::Proto::Union::HDBridge::ChannelParameter* ConfigData::add_channel_parameters() {
  ::Proto::Union::HDBridge::ChannelParameter* _add = _internal_add_channel_parameters();
  // @@protoc_insertion_point(field_add:Proto.Union.HDBridge.ConfigData.channel_parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::ChannelParameter >&
ConfigData::channel_parameters() const {
  // @@protoc_insertion_point(field_list:Proto.Union.HDBridge.ConfigData.channel_parameters)
  return _impl_.channel_parameters_;
}

// -------------------------------------------------------------------

// ScanData

// repeated .Proto.Union.HDBridge.OneChannelScanData channel_data = 1;
inline int ScanData::_internal_channel_data_size() const {
  return _impl_.channel_data_.size();
}
inline int ScanData::channel_data_size() const {
  return _internal_channel_data_size();
}
inline void ScanData::clear_channel_data() {
  _impl_.channel_data_.Clear();
}
inline ::Proto::Union::HDBridge::OneChannelScanData* ScanData::mutable_channel_data(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.Union.HDBridge.ScanData.channel_data)
  return _impl_.channel_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::OneChannelScanData >*
ScanData::mutable_channel_data() {
  // @@protoc_insertion_point(field_mutable_list:Proto.Union.HDBridge.ScanData.channel_data)
  return &_impl_.channel_data_;
}
inline const ::Proto::Union::HDBridge::OneChannelScanData& ScanData::_internal_channel_data(int index) const {
  return _impl_.channel_data_.Get(index);
}
inline const ::Proto::Union::HDBridge::OneChannelScanData& ScanData::channel_data(int index) const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ScanData.channel_data)
  return _internal_channel_data(index);
}
inline ::Proto::Union::HDBridge::OneChannelScanData* ScanData::_internal_add_channel_data() {
  return _impl_.channel_data_.Add();
}
inline ::Proto::Union::HDBridge::OneChannelScanData* ScanData::add_channel_data() {
  ::Proto::Union::HDBridge::OneChannelScanData* _add = _internal_add_channel_data();
  // @@protoc_insertion_point(field_add:Proto.Union.HDBridge.ScanData.channel_data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::OneChannelScanData >&
ScanData::channel_data() const {
  // @@protoc_insertion_point(field_list:Proto.Union.HDBridge.ScanData.channel_data)
  return _impl_.channel_data_;
}

// -------------------------------------------------------------------

// ScanDataVector

// repeated .Proto.Union.HDBridge.ScanData scan_data = 1;
inline int ScanDataVector::_internal_scan_data_size() const {
  return _impl_.scan_data_.size();
}
inline int ScanDataVector::scan_data_size() const {
  return _internal_scan_data_size();
}
inline void ScanDataVector::clear_scan_data() {
  _impl_.scan_data_.Clear();
}
inline ::Proto::Union::HDBridge::ScanData* ScanDataVector::mutable_scan_data(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.Union.HDBridge.ScanDataVector.scan_data)
  return _impl_.scan_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::ScanData >*
ScanDataVector::mutable_scan_data() {
  // @@protoc_insertion_point(field_mutable_list:Proto.Union.HDBridge.ScanDataVector.scan_data)
  return &_impl_.scan_data_;
}
inline const ::Proto::Union::HDBridge::ScanData& ScanDataVector::_internal_scan_data(int index) const {
  return _impl_.scan_data_.Get(index);
}
inline const ::Proto::Union::HDBridge::ScanData& ScanDataVector::scan_data(int index) const {
  // @@protoc_insertion_point(field_get:Proto.Union.HDBridge.ScanDataVector.scan_data)
  return _internal_scan_data(index);
}
inline ::Proto::Union::HDBridge::ScanData* ScanDataVector::_internal_add_scan_data() {
  return _impl_.scan_data_.Add();
}
inline ::Proto::Union::HDBridge::ScanData* ScanDataVector::add_scan_data() {
  ::Proto::Union::HDBridge::ScanData* _add = _internal_add_scan_data();
  // @@protoc_insertion_point(field_add:Proto.Union.HDBridge.ScanDataVector.scan_data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Union::HDBridge::ScanData >&
ScanDataVector::scan_data() const {
  // @@protoc_insertion_point(field_list:Proto.Union.HDBridge.ScanDataVector.scan_data)
  return _impl_.scan_data_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace HDBridge
}  // namespace Union
}  // namespace Proto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_HDBridge_2eproto
